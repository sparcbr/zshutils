VERSION=1.0.2

# Process handling. Stuff like pid, kill, lsof, etc...

function cwdof()
{
	for p in $(pidof $1); do
		ls -ld /proc/$p/cwd 2>/dev/null
	done | awk -F'-> ' '{print $2}' | uniq
}

function ps()
{
	local kern select search user pid ppid tty cmd
	local cols args

	[[ -o interactive ]] || { command ps "$@" ; return }
	zparseopts -D - c:=cmd k=kern u::=user p:=pid P:=ppid t:=tty o:=cols
	
	# # # # # # #
	# selection #
	# # # # # # #
	if [[ -n $user ]]; then
		[[ -n $user[2] ]] || user[2]=(${UID:-$USER})
	fi
	if [[ -z "$pid" && $1 = [0-9]## ]]; then
		pid=(-p $1)
		shift
	elif ((! $#cmd )) && [[ ${1:0:1} = [[:alnum:]_]## ]]; then
		cmd=(-C "$1")
		shift
	fi
	(( $#cmd )) && cmd[2]=("$(getfilename "$cmd[2]")")
	#if in_array args '-C'; then
	#fi
	select=($user $pid $ppid $tty $cmd)
	# hide kernel threads by default, if no other select options are given
	if (( ! $#kern && ! $#select )); then
		args+=(--ppid 2 -p 2 --deselect)
	else
		args+=($select)
	fi

	args+=("$@")

	##  ##  ##
	# output #
	##  ##  ##
	if [[ -n "$o" ]]; then
		cols=($(explode "$o[2]" ','))
		#elif in_array args --any '-o,-O'; then
	else
		cols=(pid ppid %cpu stat cmd) # euid if not -u or -u $x with $x != $UID
	fi
	args+=(-o "${(j.,.)cols}")

	run command ps $args
}

function waitOnPids()
{
	local pids=($@)
	local integer i err=0
	while [[ $#pids -gt 0 ]]; do
		sleep 0.4
		for ((i=1 ; i <= $#pids; )) do
			if kill -0 $pids[$i] 2>/dev/null; then
				((i++))
			else
				wait $pids[$i] || ((err++))
				pids[$i]=()
			fi
		done
	done
	return $err
}

# If not given a pid, run command in background
# Check command (-c): run periodically a command until main program ends
function waitPid()
{
	local ret pid cmd retCheck=2 checkCmd delay=0.4 killSent
	integer ret=0 pid killSent=0
	zparseopts -D - p:=pid c:=checkCmd d:=delay
	cmd=(${(z)@})
	[[ -n $checkCmd ]] && checkCmd=(${(z)checkCmd})
	$cmd & pid=$!
	while kill -0 $pid 2>/dev/null; do
		sleep $delay
		if [[ -n $checkCmd ]]; then
			if [[ "$killSent" -gt 3 ]]; then
				confirm "Force kill $cmd" && kill -9 $pid && break ||
					killSent=0
			fi
			$checkCmd ; ret=$?
			if [[ -n $retCheck && $ret -gt $retCheck ]]; then
				techo -c warn "Killing ${cmd[1]} ($pid)"
				kill $pid ; sleep 1
				((killSent++))
			fi
		fi
	done
	wait $pid
}

function dirtyMem()
{
	local name number
	while read name number; do
		if [[ $name = Dirty: ]]; then
			toBytes -k "$number"
			break
		fi
	done < /proc/meminfo
}

# Added 2019-07-01 16:59
function k()
{
	local kopts arg args forceProcName
	for arg; do
		if [[ ${arg:0:1} = '-' ]] && [[ $arg = -[0-9]## || ${arg:0:4} = '-sig' ]]; then
			kopts+=($arg)
		else
			args+=($arg)
		fi
	done
	set - $args
	zparseopts -M -D - f:=forceProcName
	if [[ $1 = [0-9]## ]]; then
		sudo kill "$@"
	else
		sudo killall "$@"
	fi
}

# Added 2019-04-04 15:20
function procmon()
{
	local prog=$1 timeout=5
	while true; do
		pid=$(pidof $prog)
		[[ -z "$pid" ]] && continue || e $pid
		sleep $timeout
		pid2=$(pidof $prog)
		[[ -z "$pid2" ]] && continue || e $pid2
		[[ $pid -eq $pid2 ]] && kill $pid
		sleep 1
	done
}

