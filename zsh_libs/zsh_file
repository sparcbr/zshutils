VERSION=1.0.5

setopt nomultios

function getfilename()
{
	echo "${1:t}"
}

function getfullpath()
{
	local relative
	zparseopts -D - r:=relative
	[[ $# -ge 1 ]] || return 1
	[[ -n $relative ]] && type realpath >/dev/null &&
		realpath --relative-base=${relative[2]#=} $1 2>/dev/null || echo "${1:P}"
}
function getpath()
{
	echo "${1:h}"
}

# ${file%%.old}
function getext()
{
	# echo "${1##*.}"
	echo "${1:e}"
}

function getfilenoext()
{
	echo "${1:t:r}"
}

function isDir()
{
	local dir mk
	[[ $1 = -m ]] && { mk=1; shift }
	dir=$1
	if [[ ! -d $dir ]]; then
		if [[ -e $dir ]]; then
			techo -c err "$dir is a file."
			return 2
		fi
		[[ -z $mk ]] && return 1
		confirm "dir $dir doesn't exist. Create" && run -S mkdir $dir
	fi
}

function isEmptyDir()
{
	local glob=("$1"(N/F))
	[[ -z $glob ]]
}

function noext()
{
	if [[ -n $2 ]]; then
		echo "${1%%.$2}"
	else
		echo "${1:r}"
	fi
}

# Added 2019-04-15 18:36 @TODO
function replace()
{
	local s r
	s=$1 ; r=$2 ; shift 2
	sed -i bak -e s/$1/$2/g "$@"
}

#@TODO
function backup()
{
	local sudo=""
	[[ "$1" == "-s" ]] && { shift; sudo='-s' }
	[[ -n "$2" ]] && {
		run $sudo cp "$1" "$2/$(getfilename "$1").bkup"
	} || run $sudo cp "$1" "$1.bkup"
}

#@TODO
function rename()
{
	local name dir file
	[[ "$1" == '-s' ]] && { shift; sudo='-s' }
	name="$(getfilename "$1")"
	dir="$(getpath "$1")"
	#usr/lib/arm-linux-gnueabihf/libXpm.so.4.11.0
	#usr/lib/arm-linux-gnueabihf/libXtst.so.6.1.0
	[[ -f "$1" || -d "$1" ]] || { color "$1 doesn't exist or no file permission"; return 1 }
	#file=$(dialog --title "Rename" --yes-label Rename --output-fd 1 --inputbox "Rename $1 to: " 10 120 "$name")
	file="$(input -p "Remame \"${C[warn]}$1${C[head]}\" to" $name)" || return $?
	#read "file?Remame \"$1\" to" $name || return $?
	run $sudo mv "$1" "$dir/$file"
}

function ddiff()
{
	local list cmd file sudo config
	zparseopts -D - c=config l=list s=sudo
	if [[ -n $config || -z $dir1 || -z $dir2 ]]; then
		[[ -n $1 ]] && { dir1=${1%/} ; shift }
		[[ -n $1 ]] && { dir2=${1%/} ; shift }
		#[[ -z $dir1 ]] && dir1=$(input -p "Dir 1" $dir1)
		#[[ -z $dir2 ]] && dir2=$(input -p "Dir 2" $dir2)
		d1=$dir1 d2=$dir2
		list=1
	fi

	if [[ -n $list ]]; then
		echo "dir1=$dir1 dir2=$dir2"
		return 0
	fi

	if [[ -d $dir1 && -d $dir2 ]]; then 
		if [[ -n $1 ]] && type $1 >/dev/null; then
			cmd=$1
			shift
		fi
		if [[ -z $cmd ]]; then
			[[ -n $1 ]] && run $sudo -p "diff -ur \$d1/$1 \$d2/$1" diff -ur $dir1/$1 $dir2/$1 ||
				run $sudo -p "diff -ur \$dir1 \$dir2" diff -ur $dir1 $dir2
		else
			[[ -n $1 ]] && run $sudo -p "${=cmd} \$dir1/$1 \$dir2/$1" $=cmd $dir1/$1 $dir2/$1 ||
				run $sudo -p "${=cmd} \$dir1 \$dir2" $=cmd $dir1 $dir2
		fi
	fi
}
# Added 2019-05-03 16:50
function syncDirs()
{
	local integer i n
	local src targets dir data rsArgs checksum arg
	local quiet sudo ignores dry extraArgs reverse fat
	local files stat name
	typeset -a src targets rsArgs extraArgs files
	zparseopts -D -M - q=quiet s=sudo i:=ignores d=dry t:=targets c=checksum r=reverse -fat=fat

	[[ -z "$sudo" ]] && sudo='-S'
	[[ $# -ge 2 ]] || abort 1 "usage: $0 source1 [.. sourceN] target1[,target2]"
	
	n=$#
	for arg; do
		if [[ ${arg:0:1} = - ]]; then # option parameter
			extraArgs+=($arg)
		else # sources
			src+=($arg)
		fi
	done
	targets=${src: -1}
	src[$#src]=()
	targets=($(explode $targets ','))

	if [[ -n $reverse ]]; then
		files=($targets)
		targets=($src)
		src=($files)
	fi
#	if [[ -n "$1" ]]; then
#		targets="${@: -1}"
#		src=("${@:1:-1}")
#	else
#		src=($(box get backupdirs))
#	fi
#	if [[ -z "$targets" ]]; then
#		targets="$(input "Enter target directory")" || abort $?
#	fi


	# # # # # # # # # #	   -t, --times           preserve modification times
	# rsync arguments #    -O, --omit-dir-times  omit directories from --times
	# # # # # # # # # #    -J, --omit-link-times
	# [[ -n $fat ]]
	rsArgs=( -hlDr )
	if [[ -n $checksum ]]; then
		rsArgs+=(-c --no-times)
	else
		rsArgs+=(-tu)
	fi 
	# exclusions
	rsArgs+=(--exclude=.osync_workdir --exclude='backup*' --exclude='*.local' --exclude='.bsync*')
	[[ -n $ignores ]] && rsArgs+=(--exclude-from="${ignores[2]}")
	for ((n=1; n<=$#src; n++)); do
		if isDir "${src[$n]}"; then
			if [[ -f "${src[$n]}/rsync.ignore" ]]; then
				rsArgs+=(--exclude-from="${src[$n]}/rsync.ignore")
			fi
			if isEmptyDir $src[$n]; then
				techo -c err "Empty directory$C_: $C[lred]$src[$n]"
				return 1
			fi
			[[ ${src[$n]: -1} != / ]] && src[$n]+=/
		fi
	done
	# rsync arguments from command line
	rsArgs+=("${extraArgs[@]}")

	# # # # # #
	# Targets #
	# # # # # #
	for dir in $targets; do
		if isDir -m "$dir"; then
			data="$(run $sudo rsync -nipog ${rsArgs[@]} "$src[@]" "$dir")"
			if [ -n "$data" ]; then
				echo $data
				confirm "Do it" && # run --confirm "Do it"
					run $sudo rsync -pog --info=PROGRESS2 "$rsArgs[@]" "$src[@]" "$dir"
				_sync
			fi

			# # # # # # #
			# Deletions #
			# # # # # # #
			data="$(run $sudo rsync -ni --delete --existing --ignore-existing \
				-JO ${rsArgs[@]} $src[@] $dir)"

			if [[ -n "$data" ]]; then
				techo -c warn "Deletions:"
				n=0
				echo $data | while read stat name; do
					echo "$dir/$name ${C[red]}❌$C_"
					files+=($dir/$name)
					((n++))
				done
				confirm -c warn "Delete these $n files" || continue
				#@TODO rm $(chooser "$files[@]")
				run $sudo rsync --delete --existing --ignore-existing \
					--info=PROGRESS2 "$rsArgs[@]" "$src[@]" "$dir"
				_sync
			fi
		fi
	done
}

# Added 2019-01-22 18:07:09 @TODO
function syncIhm()
{
	( cd $HOME/PeD/android && {
		syncDirs -c -i $CFG/android.ignore $TREADMILL \
			$CLOUD_APPS/Treadmill,/m/home/inbramed/android/Treadmill
		syncDirs -c -i $CFG/android.ignore $CICLOERGOMETER \
			$CLOUD_APPS/Cicloergometer,/m/home/inbramed/android/Cicloergometer
	  }
	)
}

# Added 2019-02-20 09:23:39 @TODO
function boxStart()
{
	include boxes
	box start
}


# Added 2019-06-05 16:55
function attributeSync()
{
	local stats name dir1 dir2 rsArgs skip dry
	#[[ $# -gt 2 ]] || return 10
	zparseopts -D - d=dry

	[[ -n $dry ]] && dry=techo
	[[ -n $1 ]] && { dir1=$1 ; shift }
	[[ -n $1 ]] && { dir2=$1 ; shift }

	if [[ ! -d $dir1 || ! -d $dir2 ]]; then
		[[ -d $dir1 ]] || techo -c lred "$dir1: not a directory"
		[[ -d $dir2 ]] || techo -c lred "$dir2: not a directory"
		return 127
	fi
	confirm "$dir1 -> $dir2" || return
	rsArgs=(${@:--u})
	while read stats name skip; do
		#echo stat=$stats name=$name ;
		[[ $stats == skipping ]] 
		[[ $stats[5] == t ]] && $dry sudo touch --reference "$dir1/$name" $dir2/$name
		[[ $stats[6] == p ]] && $dry sudo chmod --reference "$dir1/$name" $dir2/$name
		if [[ $stats[7] == o || $stats[8] == g ]] && [[ $stats != skipping ]]; then
			$dry sudo chown --reference "$dir1/$name" $dir2/$name
		fi
	done < <(run -s rsync -n -hDirtpog $rsArgs $dir1/ $dir2 | tee $TTY)
	sync
}

function _sync() {
	local pid
	techo "Flushing caches to disk. Please wait."
	run sync & pid=$!
	watch -n 1 -c -t  "grep -e 'Dirty:' -e 'Writeback:' /proc/meminfo; kill -0 $pid || killall watch"
}
