VERSION=1.0.9
#lazyload=syncDirs,urlfollow,urlinfo,vnc,imdb,globo,awkWrapper,getfullpath,getpath,getext,getfilename,isDir,isEmptyDir,box,ddiff

[[ -v comp ]] || typeset -ga comp

setopt nomultios

function getfilename()
{
	echo "${@:t}"
}

function getfullpath()
{
	local relative
	zparseopts -D - r:=relative
	(( $# )) || return 1
	[[ -n $relative ]] && type realpath >/dev/null &&
		realpath --relative-base=${relative[2]#=} $1 2>/dev/null || echo "${(z)1:P}"
}
function getpath()
{
	echo "${1:h}"
}

# ${file%%.old}
function getext()
{
	# echo "${1##*.}"
	echo "${1:e}"
}

function getfilenoext()
{
	echo "${1:t:r}"
}

function isDir()
{
	local dir mk
	[[ $1 = -m ]] && { mk=1; shift }
	dir=$1
	if [[ ! -d $dir ]]; then
		if [[ -e $dir ]]; then
			techo -c err "$dir is a file."
			return 2
		fi
		[[ -z $mk ]] && return 1
		confirm "dir $dir doesn't exist. Create" && run -S mkdir -p $dir
	fi
}

function isEmptyDir()
{
	local glob=("$1"(N/F))
	[[ -z $glob ]]
}

# @description: remove extension
# @arg2: optional extension. If given remove only if extension = this
# @returns: full path (or filename if no path given) without extension
function noext()
{
	if [[ -n $2 ]]; then
		echo "${1%%.$2}"
	else
		echo "${1:r}"
	fi
}

# Added 2019-04-15 18:36 @TODO
function replace()
{
	local s r
	s=$1 ; r=$2 ; shift 2
	sed -i bak -e s/$1/$2/g "$@"
}

#@TODO
function backup()
{
	local sudo=""
	[[ "$1" == "-s" ]] && { shift; sudo='-s' }
	[[ -n "$2" ]] && {
		run $sudo cp "$1" "$2/$(getfilename "$1").bkup"
	} || run $sudo cp "$1" "$1.bkup"
}

#@TODO
function rename()
{
	local orig name dir fullpath
	(( $# )) || usage $0
	#@TODO is link? confirm rename link or link target
	[[ "$1" == '-s' ]] && { shift; sudo='-s' }
	orig="$(getfilename "$1")"
	dir="$(getpath $(getfullpath $1))"
	fullpath="$dir/$orig"
	[[ -f "$1" || -d "$1" ]] || abort 127 "$1 doesn't exist or no file permission"
	name=${2:-$orig}
	if input -r -p "Rename \"${C[warn]}$fullpath${C[head]}\" to" -v name && \
		[[ -n $name && $name != $orig ]]
	then
		run $sudo mv "$fullpath" "$dir/$name"
	fi
}

function ddiff()
{
	local list cmd file sudo config var dargs r u q
	zparseopts -D -M - c=config -set=c l=list s=sudo i:=ignore q=q

	echo "dir1=$dir1\ndir2=$dir2"
	[[ -n $list ]] && return 0
	
	dargs=(-u -r)
	[[ -n $q ]] && dargs+=($q)

	if [[ -n $config || -z $dir1 || -z $dir2 ]]; then
		if [[ -n $config ]]; then
			if [[ -n $1 ]]; then
				isDir $1 && dir1=${1%/} || return
				shift
			fi
			if [[ -n $1 ]]; then
				isDir $1 && dir2=${1%/} || return
				shift
			fi
		fi
		local buttons=(--okcodes '0 1' -b "Current directory [$PWD]:1")
		if [[ -z $dir1 || -n $config ]]; then
			var=$dir1
			input -p "Dir 1" -v var $buttons || return
			isDir -m $var && dir1=$var || return
		fi
		if [[ -z $dir2 || -n $config ]]; then
			var=$dir2
			input -p "Dir 2" -v var $buttons || return
			isDir -m $var && dir2=$var || return
		fi
		d1=$dir1; d2=$dir2
		techo "dir1: $dir1\ndir2: $dir2"
	fi

	if [[ -d $dir1 && -d $dir2 ]]; then 
		if [[ -n $1 ]] && type $1 >/dev/null; then
			cmd=$1
			shift
		fi
		if [[ -z $cmd ]]; then
			[[ -n $1 ]] && run $sudo -p "diff -ur \$d1/$1 \$d2/$1" diff $dargs $dir1/$1 $dir2/$1 ||
				run $sudo -p "diff -ur \$dir1 \$dir2" diff $dargs $dir1 $dir2
		else
			[[ -n $1 ]] && run $sudo -p "${=cmd} \$dir1/$1 \$dir2/$1" $=cmd $dir1/$1 $dir2/$1 ||
				run $sudo -p "${=cmd} \$dir1 \$dir2" $=cmd $dir1 $dir2
		fi
	fi
}

# Added 2019-05-03 16:50
comp+=("syncDirs=rsync")
function syncDirs()
{
	integer n
	local dir data checksum arg noDelete
	local quiet sudo excludeFrom exclude dry reverse
	local stat name noSlash sshCFG ret host p
	typeset -aU src targets rsArgs extraArgs files excludePatterns
	zparseopts -D -M - q=quiet s=sudo d=dry \
		c=checksum r=reverse -no-add-slash=noSlash -no-delete=noDelete \
		E:=excludeFrom -exclude-from:=E e:=exclude -exclude:=e

	[[ -z "$sudo" ]] && sudo='-S'
	(($# >= 2)) || abort 1 "usage: $0 source1 [.. sourceN] target1[,target2]"
	
	n=$#
	for arg; do
		if [[ ${arg:0:1} = - ]]; then # option parameter
			extraArgs+=($arg)
		else # sources
			src+=("$arg[@]")
		fi
	done
	if [[ $#src -ge 2 ]]; then
		explode -v targets $src[-1] ','
		src[$#src]=()
	fi
	#if [[ $#src -eq 0 ]]; then
	#	src=($(box get backupconfig))
	#fi
	if ((!$#targets)); then
		#@TODO: show current selected directories and allow addition and removal
		local buttons=(--okcodes '0 1' -b "Current directory [$PWD]:1")
		input --multi --dir -p 'Enter target directories' -v targets || cancel
	fi

	if [[ -n $reverse ]]; then
		files=($targets)
		targets=($src)
		src=($files)
	fi

	# # # # # # # # # #	   -t, --times           preserve modification times
	# rsync arguments #    -O, --omit-dir-times  omit directories from --times
	# # # # # # # # # #    -J, --omit-link-times
	rsArgs=( -hlDr )
	if [[ -n $checksum ]]; then
		rsArgs+=(-c --no-times)
	else
		rsArgs+=(-tu)
	fi 

	# exclusions
	if [[ -n $exclude ]]; then
		explode -v excludePatterns $exclude[2] ' '
	fi
	excludePatterns+=(.osync_workdir 'backup*' '*.local' '.git' 'node_modules')
	rsArgs+=(--exclude=$^excludePatterns)
	[[ -n $excludeFrom ]] && rsArgs+=(--exclude-from="${excludeFrom[2]}")

	# analyse sources
	for ((n=1; n<=$#src; n++)); do
		local isEmptyDir=0

		dir=$src[$n]
		if [[ $dir =~ ([^:]+):(.*) ]]; then		 # remote
			host=$match[1]
			p=$match[2]

			#include -q network
			#if [[ -n $sshCFG[$host] ]]; then
			#	sshArgs=(ssh $sshCFG[$host])
			#fi

			ret=($(ssh $host \
				"if [[ -d $p ]]; then
					glob=("$p"(N/F))
					v=\$#glob
					if ((v)) && [[ -f $p/rsync.ignore ]]; then
						echo -n 1i
					else
						echo -n \$v
					fi
				elif [[ -f $p ]]; then
					echo -n f
				fi"
			))
			case $ret in
				1*) # dir
					((!$#noSlash)) && [[ ${dir: -1} != / ]] && src[$n]+='/'
					if [[ $ret == '1i' ]]; then
						#@TODO: scp $dir/rsync.ignore /tmp)
						#rsArgs+=(--exclude-from=$fIgnore)
					fi
					;;
				f) ;; # file
				0)
					confirm -c warn "@TODO Empty remote directory$C_: $C[lred]'$host:$p'. \
						Create dir" || cancel
					src[$n]=(); ((n--))
					;;
				'')
					confirm -c warn "Source $host:$p not found. Ignore and continue" || cancel
					src[$n]=(); ((n--))
					;;
				*) abort 1 "Invalid response from $host: '$ret'" ;;
			esac
		elif [[ -d $dir ]]; then
			if isEmptyDir $dir; then
				confirm -c warn "Empty directory$C_: $C[lred]'$dir'. \
					Ignore and continue" || cancel
				src[$n]=(); ((n--))
			else
				((!$#noSlash)) && [[ ${dir: -1} != / ]] && { dir+='/'; src[$n]+='/' }
				if [[ -f ${dir}rsync.ignore ]]; then
					rsArgs+=(--exclude-from=${dir}rsync.ignore)
				fi
			fi
		fi
	done
	techo -c lcyan "Sources: ${(@qq)src}"
	techo -c lcyan "Targets: ${(@qq)targets}"
	# rsync arguments from command line
	rsArgs+=($extraArgs)
	techo -c lcyan "rsync args: ${(@qq)rsArgs}"

	# # # # # #
	# Targets #
	# # # # # #
	local nothing=1 permFlags
	for dir in $targets; do
		host=''; p=''  #sshArgs
		if [[ $dir =~ ([^:]+):(.*) ]]; then
			host=$match[1]; p=$match[2]
		elif ! isDir -m $dir; then
			techo -c warn "Skipping $dir"
			continue
		fi

		if ((1)); then
			permFlags=''
			if (($#host)); then # remote
				permFlags='-p' # og'
			else
				[[ "$(fstypeof $dir)" != 'vfat' ]] && permFlags='-p' #og'
			fi
			#data="$(run $sudo rsync -ni ${sshArgs[@]} ${rsArgs[@]} $permFlags "$src[@]" $dir)"
			data="$(run $sudo rsync -ni ${rsArgs[@]} $permFlags "$src[@]" $dir)"
			if (($#data)); then
				nothing=0
				echo $data
				if confirm "Do it"; then
					run $sudo rsync --info=PROGRESS2 $rsArgs $permFlags $src $dir || abort
				else
					cancel
				fi

				# @TODO((!isRemote && !noSync)) && _sync
			fi

			if ((!$#noDelete)); then
				# # # # # # #
				# Deletions #
				# # # # # # #  @TODO: -J (omit-link-times) does not work on old rsync
				data="$(run $sudo rsync -ni --delete --existing --ignore-existing \
					-O ${rsArgs[@]} $src[@] $dir)" || abort

				if [[ -n "$data" ]]; then
					nothing=0
					techo -c warn "Deletions:"
					n=0
					echo $data | while read stat name; do
						echo "$dir/$name ${C[red]}❌$C_"
						files+=($dir/$name)
						((n++))
					done
					confirm -c warn "Delete these $n files" || continue
					#@TODO rm $(chooser "$files[@]")
					run $sudo rsync --delete --existing --ignore-existing \
						--info=PROGRESS2 $rsArgs $src $dir || abort
					_sync
				fi
			fi
		fi
	done
	[[ $nothing -eq 1 ]] && techo -c cyan "Nothing to do"
	return 0
}

# Added 2019-02-20 09:23:39 @TODO
function box()
{
	local box base=$HOME/repos cmd search list
	#zparseopts -D -M - 
	include -r functions
	include -l network
	#include boxes

	if (($#)); then
		cmd=$1 ; shift ; box="$*"
	else
		cmd='search'
		box="$@"
	fi

	while ((1)); do
		case $cmd in
			new)
				if [[ -z $box ]]; then
					input -v box -p 'Enter git url or name to search' || cancel
				fi
				gclone $box #&& BOX=$box
				return
				#mkdir $base/$box
			;;
			open)
				if [[ $box == '.' ]]; then
					 box=$BOX
				fi
				cd $base/$box || return
				BOX=$box
				[[ -d .git ]] && git status &
				[[ -d android ]] && include android
				todo -d . #@TODO mv to cd hook
				return 0
			;;
			start|run)
				#@TODO
				if [[ -z $box ]]; then
					[[ -n $BOX ]] || abort 10
					box=$BOX
				else
					#@TODO: glob search name, if count==1 box=result
					result=($base/(#i)*${box}*)
					(($#result)) || abort 10
					chooser --simple -v box $result:t || cancel
				fi
				if [[ -d $base/$box/node_modules ]]; then
					(cd $base/$box/node_modules ; npm start &)
				fi
				return
			;;
			list|search)
				search=$box
				if [[ -n $search && -d $base/$search ]]; then
					cmd='open'; box=$search
					continue
				fi

				list=($base/*(-/omN))
				(($#list)) || return 10
				chooser --simple -v box -f1 ${=box:+-S $search} $list:t 'New box' || cancel
				if [[ $box == 'New' ]]; then
					cmd='new' ; box=''
				elif [[ -d $base/$box ]]; then
					cmd='open'
				fi
			;;
			*)
				box=$cmd
				cmd='search'
				#abort -v5 1 "Invalid command: $C[warn]$cmd$C_. Commands: open, list/search, new, start"
			;;
		esac
	done
}


# Added 2019-06-05 16:55
function attributeSync()
{
	local stats name dir1 dir2 rsArgs skip dry
	#[[ $# -gt 2 ]] || return 10
	zparseopts -D - d=dry

	[[ -n $dry ]] && dry=techo
	[[ -n $1 ]] && { dir1=$1 ; shift }
	[[ -n $1 ]] && { dir2=$1 ; shift }

	if [[ ! -d $dir1 || ! -d $dir2 ]]; then
		[[ -d $dir1 ]] || techo -c lred "$dir1: not a directory"
		[[ -d $dir2 ]] || techo -c lred "$dir2: not a directory"
		return 127
	fi
	confirm "$dir1 -> $dir2" || return
	rsArgs=(${@:--u})
	while read stats name skip; do
		#echo stat=$stats name=$name ;
		#[[ $stats == skipping ]] 
		[[ $stats[5] == t ]] && $dry sudo touch --reference "$dir1/$name" $dir2/$name
		[[ $stats[6] == p ]] && $dry sudo chmod --reference "$dir1/$name" $dir2/$name
		if [[ $stats[7] == o || $stats[8] == g ]] && [[ $stats != skipping ]]; then
			$dry sudo chown --reference "$dir1/$name" $dir2/$name
		fi
	done < <(run -s rsync -n -hDirtpog $rsArgs $dir1/ $dir2 | tee $TTY)
	_sync
}

#@TODO
function _sync() {
	#run -w "isDirty" -p "Flushing caches to disk. Please wait." sync
	run -p "Flushing caches to disk..." sync
	#watch -n 1 -c -t  "grep -e 'Dirty:' -e 'Writeback:' /proc/meminfo; kill -0 $pid || killall watch"
}

# Added 2019-08-21 00:27
function fordir() #TODO
{
	local d cmd args dirs i=1 verbose
	zparseopts -D -M - v:=verbose
	[[ $# -gt 0 ]] || usage
	if ((! $+verbose[2])); then
		verbose=(-v 0)
	fi
	for d; do
		if [[ -d "$d" ]]; then
			dirs+=("$d")
		elif type "$d" 2>&1 >/dev/null; then
			cmd="$d"
			shift
			break
		fi
		shift
	done
	[[ -n $cmd ]] || usage 'Missing command'
	args=("$@")
	[[ -n "$dirs" ]] || dirs=(*(-/))
	for d in $dirs; do
		run $verbose "$cmd" $args "$d"
	done
}

# Added 2019-06-07 17:27
function fordo() #TODO
{
	techo FIXME
	local v cmd
	cmd=$1; shift
	for v; do
		run - $=cmd $v
	done
}

function show() #TODO
{
	local cmd
	type bat 2>&1 >/dev/null && cmd='bat' || cmd='cat'
	$cmd "$@"
}

# Added 2019-11-05 23:25
function diff()
{
	command diff --color=always "$@"
}

function uniqfile()
{
	local suffix prefix name base
	zparseopts -D -M - S:=suffix P:=prefix
	[[ -n $prefix ]] && prefix=$prefix[2]
	[[ -n $suffix ]] && suffix=.${suffix[2]#.}
	if (($#1)); then
		base=$1
		[[ -n $prefix ]] && base=${base#$prefix}
		if [[ -n $suffix ]]; then
			base=${base%$suffix}
		else
			suffix=.${base:e}
		fi
	fi
	name="$prefix$base$suffix"
	if [[ -z $name ]]; then
		techo 'empty filename'
		return 1
	fi
	if [[ -e $name ]]; then
		name="$prefix$base$(date +"%Y%m%d-%H%m%S")$suffix"
	fi
	echo -n $name
}

typeset -gA awkFuncs
awkFuncs=(
	printArgs '(i,f) {\
		if (i<0) i=NF+i+1; 	if (f<0) f=NF+f+1;\
		for (j=i ; j<f ; j++) {\
			printf("%s%s", $j, OFS);\
		}\
		if (j==f) print $j; }'
	printArray '(A,i,f){\
		if (i<0) i=length(A)-i+1; 	if (f<0) f=length(A)-f+1;\
		for (j=i ; j<f ; j++) {\
			printf("%s%s", A[j], OFS);\
		}\
		if (j==f) print A[j]; }'
)

function awkWrapper()
{
	_dbg_trap $0
	local opts prog _vars _expr _out _inc reSep
	local _mapCols _cols
	zparseopts -D -M - v:=_vars F:=reSep E=_expr e:=_expr o:=_out \
		I:=_inc -inc:=I C:=_mapCols -mapColumns:=C # c:=_cols -cols:=c

	if [[ -n $_vars ]]; then
		_vars=(${(P)_vars[2]})
		opts=('-v '$^_vars)
		opts=($=opts)
	fi
	(($#reSep)) && opts+=($reSep)

	prog=''
	if (($#_inc)); then #@TODO
		local fname=$_inc[2]
		((${+awkFuncs[$fname]})) || abort 127 "Undefined function $C[warn]$fname"
		prog+="function ${fname}${awkFuncs[$fname]}"$'\n'
	fi

	if (($#_expr)); then
		if (($#_expr > 1)); then	# -e varname
			_expr=(${(P)_expr[2]})
		else						# -E
			_expr=("$@[1,4]")
		fi
		local x m pat action
		for x pat m action in $_expr; do
			if [[ $x == <-> ]]	; then
				prog+="x==$x"
			elif [[ $x =~ 'BEGIN|END' ]]; then
				prog+="$x { $action }"$'\n'
				continue
			elif [[ $x == 'function' ]]; then
				prog+="function $action"$'\n'
				continue
			elif [[ $x != '-' ]]; then
				prog+=$x
			fi
			
			if [[ $pat != '-' ]]; then
				if [[ $x != '-' ]]; then
					prog+=' && '
				fi

				if [[ $m != '-' ]]; then
					prog+="match(\$0,$pat,$m)"
				else
					prog+=$pat
				fi
			fi

			prog+=" { $action }"$'\n'
		done
	fi

	if (($#_out)); then
		_out=$_out[2]
		if (($#_mapCols)); then
			local key val
			_mapCols=$_mapCols[2]
			typeset -g $_out $_mapCols
			typeset -A _row
			while read key val; do
				(($#key)) || break
				col=${${(P)_mapCols}[$key]}
				[[ -z $col ]] && abort 1 "Invalid column: $key"
				_row+=($col $val)
			done < <(awk $opts $prog $1)
			set -A $_out ${(kv)_row}
		elif (($#_cols)); then
			_cols=$_cols[2]
			typeset -ga $_out $_cols
			_row=()
			{
				integer i=0
				read -A $_cols
				IFS=$'' read -d '' -A $_out
				#while read ... $_out; do
					#col=${${(P)_cols}[$key]}
					#[[ -z $col ]] && abort 1 "Invalid column: $key"
					#_row+=($col $val)
				#	_row+=($col $val)
				#	((i++))
				#done
			} < <(awk $opts $prog $1)
		else
			#save line by line to array
			set -A $_out "${(@f)$(awk $opts $prog $1)}"
		fi
	else
		# raw awk output to stdout
		awk $opts $prog $1
	fi
}
