VERSION=1.0.2
#lazyload=gclone,github,gh,gpush,pull,push
[[ ! -v comp ]] && typeset -g -a comp
export github_token='b2e74253b94398066f3938bb63120f51ca7745ee'

alias pull="git pull"
alias push="gpush"
alias gdiff="git diff --ignore-space-at-eol -b -w --ignore-blank-lines --minimal"
alias gadd="git add"
alias gadd-modified="git add \$(git diff --name-only --relative)"
alias gshow="git show --color=always"
alias unstage="gunstage"
alias git_get_tag='git describe --tags $(git rev-list --tags --max-count=1)'
alias gchk='git checkout'
alias glog2='git log --date=iso -g'
# repos
alias maquina="cd ~/MaquinaDeConversao/www/api.maquinadeconversao.com.br"
alias idiomus="cd ~/xdata/idiomusAPI"
alias q48="cd ~/Q48API"

comp+=('gunstage=git')
function gunstage()
{
	git restore --staged "$@"
}

function gfollow()
{
	local hash entries pat REPLY
	zparseopts -M -D - d=diff -diff=d
	log=$(egrep '^commit' <(git log --follow "$@") | awk '{print $2}')
	for hash in $log; do
		gdiff $hash -- "$@" | more
	done
}

function gtag()
{
	local tag hash
	echo TODO
	return 1
	hash=${2:-$(gselect -h)}
	tag=$()
	git tag -a $tag $hash
}

function gmerge() #@TODO
{
	local branch=${1:-$(chooser $(git branch))}
	[[ -n $branch ]] && run git merge $branch --no-ff --no-commit
}

function ggrep() #@TODO
{
	local files pattern
	pattern=$(echo "$@" | awk -F' - ' '// {print $1}')
	files=$(echo "$@" | awk -F' - ' '// {print $2}')
	#pattern="${@%%_*}"
	#files="${@#*_}"
	#while arg in "$@"; do
	#    [[ "$arg" != "--" ]]
	#    [[ ]] && files+=" $arg"
	#done
	set -x
	git grep "$pattern" $(git rev-list --all -- ${=files}) -- ${=files}
	set +x
}

function commit() #@TODO
{
	local m args
	zparseopts -D -M - m:=m
	if [[ -n "$1" && ${1:0:1} != - ]]; then
		m=(-m "$*")
	else
		args="$@"
	fi
	git commit $m $args
}
function croot()
{
	git config --global --get alias.root > /dev/null || git config --global --add alias.root '!pwd'
	alias croot='cd $(git root)'
	cd $(git root)
}

# Added 2019-01-25 11:17:01
# https://github.com/search?q=
comp+=('github=cd' 'gh=cd')
function github()
{
	local url repo search echo
	zparseopts -D -M - r=repo s=search e=echo
	if [[ $# -eq 0 ]]; then
		url=$(gitgetrepo .) || url='https://github.com/'
		open $url
	elif [[ -n $search ]]; then
		open "https://github.com/search?q=$(omz_urlencode $*)"
	elif [[ -n $repo ]]; then
		url="https://github.com/$*"
		[[ -n $echo || ! -t 1 ]] && echo $url || open $url
	elif url=$(gitgetrepo "$*"); then
		[[ -n $echo || ! -t 1 ]] && echo $url || open $url
	else
		githubAPI $echo "$@"
	fi
}
alias gh='github'
typeset -Tf github
#
function githubAPI()
{
	local limit=20 endpoint='https://api.github.com/graphql' #request response fields
	local echo verbose ret
	zparseopts -D -M - e=echo v=verbose

	request=$(cat) <<-GQL
	{ 
		"query":"query(\$search:String!,\$limit:Int!){
			search(query:\$search, first: \$limit, type: REPOSITORY){
				nodes {
				... on Repository {
					nameWithOwner, createdAt, updatedAt, stargazers { totalCount }, description
				}
				}
			}
		}",
		"variables":{ "search":"fork:true $*","limit":$limit }
	}
	GQL
	#	"variables":{ "search":"fork:true $(omz_urlencode "$*")","limit":$limit }
	fields='.data.search.nodes[] | .nameWithOwner,.createdAt[0:10],.updatedAt,.stargazers.totalCount,.description'
	request=${request//$'\n'/}
	response=$(curl -sS -H "Authorization: bearer $GITHUB_API_TOKEN" -X POST -d $request $endpoint)
	ret=$?
	type jq >/dev/null || chkCmdInstall jq 
	(($#verbose)) && {
		jq -r <<<$request
		jq -r <<<$response
	}
	if ((ret == 0)); then
		local field
		typeset -a repos tmp
		while read -r field; do
			tmp+=("$(trim "$field")")
			if (($#tmp == 5)); then
				repos+=("$tmp")
				tmp=
			fi
		done < <(jq -cr "$fields" <<<$response)

		if ((!$#repos)); then
			abort 10 'No repositories found'
		elif (($#repos == 1)); then
			github -r $echo $(explode "$repos" ' ' 1)
		else
			name=$(chooser -s' ' -f1 $repos "Open this search in github") || cancel
			if [[ $name == 'Open' ]]; then
				github -s "$*"
			else
				github -r $echo $name
			fi
		fi
	fi
}

function gitgetrepo()
{
	local repo d remote
	zparseopts -D -M - d:=d
	(
		d=${d[2]:-"$*"}
		if [[ -n $d && -d $d ]]; then
			cd $1 || {
				[ -t 1 ] && techo -c err "Directory not found: $1"
				return 1
			}
		fi
		gremote || { techo -c warn 'No remotes'; return 10 }
		repo=$(git remote get-url $remote[1] 2>/dev/null) || {
			[ -t 1 ] && techo -c err 'Git repository not found'
			return 1
		}
		[[ -n $repo ]] && echo $repo || {
			[ -t 1 ] && techo -c err 'No remotes'
			return 10
		}
	)
}

function gselect()
{
	local var line lines noSelect nlimit='-500'
	integer i n
	setopt extendedglob
	lines=("${(@f)$(git log --graph --oneline --all $nlimit $@)}")

	# mark lines without content as non-selectable
	n=$#lines
	for ((i=1; i<=n; i++)); do
		if [[ ! $lines[$i] =~ [a-f0-9] ]]; then
			noSelect+=($i)
		fi
	done
	chooser -n $noSelect -R '([a-f0-9]{5,40} .*)' $lines
	#line=(${=line##[^a-f0-9]#})
}

function gpush()
{
	local remote
	if ! git push "$@"; then
		remote=${1:-$VCS_STATUS_REMOTE_NAME}
		[[ -z $remote ]] && gremote
		branch=${2:-$VCS_STATUS_LOCAL_BRANCH}
		[[ -z $branch ]] && gbranch
		git push --set-upstream $remote[1] $branch
	fi
}

function gbranch()
{
	#local current
	#zparseopts c=current
	
	branch=$(git symbolic-ref --short ${1:-HEAD})
}

function gremote()
{
	#local current
	#zparseopts c=current
	
	remote=($(git remote))
}

# Added 2019-09-03 19:04
function gclone()
{
	local repo
	cd $HOME/repos
	for repo; do
		if [[ -n "$(url getscheme $repo)" ]] || repo="$(github -e $repo)"; then
			git clone $repo
		fi
	done
	[[ -d $repo ]] && cd $repo
}
