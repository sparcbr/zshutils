VERSION=1.0.5
#lazyload=gdiff,gclone,gpr,commit,github,gpush,croot,gfollow,gunstage,gmerge,gchk,gbranch,grebase,gshow,gitgetrepo,glog,gstaged,grestore,gstatus,gpull
alias pull="gpull"
alias push="gpush"
alias gadd="git add"
alias gadd-modified="git add \$(git diff --name-only --relative)"
alias gh='github'
alias unstage="gunstage"
alias git_get_tag='git describe --tags $(git rev-list --tags --max-count=1)'
alias gd='gdiff'
alias gdi='gdiff --interactive'
alias gsh='gshow'
alias gls='git ls-files'
unalias glog 2>/dev/null
alias gst='gstatus'
alias gstat='gstatus'
alias grest='grestore'
alias staged='gstaged'
alias gds='gstaged'

export github_token='b2e74253b94398066f3938bb63120f51ca7745ee'

[[ ! -v comp ]] && typeset -g -a comp

#@TODO configs:

function gconfig()
{
	local _opts _opt _gopts
	#zparseopts -D -M -A _opts -
	git config --list --show-scope || return

	return
	chooser -v _opt -p 'git config' -f1 'Unset' 'Cancel' || return
	case $_opt in
		Unset)
			git pull --no-commit "$@"
			;;
		Cancel) cancel ;;
			*)	;;
	esac

	git config --global core.excludesfile $CFG/.gitignore_global
	git config --global diff.algorithm histogram
	git config --global merge.conflictstyle diff3
	# or in repopath/.git/info/exclude
	#if [[ -z $PAGER && -z $GITPAGER ]]; then
	#	chooser -v PAGER -f1 'less' 'bat' '- *no pager*'
	#	[[ $PAGER == '-' ]] && PAGER=''
	#	git config --global core.pager
	#fi

	#git config --global $opt $val
	# 'color.ui' 'auto'
}

function gpull()
{
	local tmp _opts _opt gopts=()
	#zparseopts -D -M -A _opts -
	tmp=$(git pull --ff-only "$@" 2>&1) || {
		if [[ $tmp =~ 'fatal: Could not read from remote' ]]; then
			# on network=1 gpull
			return 1
		fi
		chooser -v _opt -p 'No fast-forward possible' -f1 'Merge pull' 'Cancel' || return
		case $_opt in
			Merge)
				git pull --no-commit "$@"
				;;
			Cancel) cancel ;;
				*)	;;
		esac
	}
}

function gshow()
{
	local _opts gopts=()
	zparseopts -D -M -A _opts - l -list=l

	(($+_opts[-l])) && gopts=('--name-only')

	git show $gopts "$@"
}

comp+=('gchk=git')
function gchk()
{
	git checkout "$@" && git status
}

function gstaged()
{
	gdiff --staged "$@"
}

comp+=('gunstage=git')
function gunstage()
{
	grestore --staged "$@"
}

function gselect()
{
	local msgsearch search filePattern revisions
	integer ret i idx nlimit=20 hasDashDash
	typeset -a lines _opts _copts g1opts gFixedOpts noSelect head gargs
	setopt extendedglob
	zparseopts -D -M -A _opts - 'l' -nograph=l -oneline=l n: -follow g: -grep:=g G:

	(($+_opts[-n])) && nlimit=$_opts[-n]
	(($+_opts[--follow])) && glopts+=(--follow)
	(($+_opts[-g])) && msgsearch=$_opts[-g]
	(($+_opts[-G])) && search=$_opts[-G]
	((! $+_opts[-l])) && gFixedOpts+=('--graph')
	gFixedOpts+=(--relative)

	# separate revisions(branches/commits) and paths
	#while [[ ${1[1]} == '-' ]]; do
	#	if [[ $1 == '-' || $1 == '--' ]]; then
	#		shift
	#		hasDashDash=1
	#		break
	#	fi
	#	gargs+=("$1")
	#	shift
	#done
	while ((ret==0)); do
		_copts=()
		noSelect=()
		head=()
		glopts=($gFixedOpts)
		if (($#msgsearch)); then
			glopts+=(--grep "$msgsearch")
			#TODO input -P Search -v search
			head+=("$C[head]Search message:$C_ $msgsearch")
		fi
		if (($#filePattern)); then
			#TODO multiple files
			glopts+=(--follow)
			head+=("$C[head]Following:$C_ $filePattern")
		fi
		((nlimit)) && glopts+=(-n $nlimit)

		glog -v lines $glopts "$@" -- $filePattern
		# mark lines without content as non-selectable
		for ((i=1; i<=$#lines; i++)); do
			if [[ ! $lines[i] =~ [a-f0-9]{5,} ]]; then
				noSelect+=($i)
			fi
		done
		(($#noSelect)) && _copts+=(-n "$noSelect")

		_copts+=(
			--foot '(Enter) Show (V|E) Vim (F) Full (D) Diff (M) Meld (Esc) Quit'
			--events '[ve] EDIT f FULL d DIFF m MELD F3 GREP'
			--strip-color
			-R '([a-f0-9]{5,40} .*)' -f1
		)

		(($#head)) && _copts+=(--head "$head")

		while { chooser -v hashes --items lines -D $idx -I idx $_copts ; ret=$? ; ((ret==0)) }
		do
			case $ACTION in
				'')
					gshow $gs_opts $hashes $1
					;;
				'EDIT')
					# save to:
					gshow $hashes $1 | gvim -
					#gvim -f $1
					;;
				'FULL')
					gshow $hashes:$1 | gvim -
					;;
				'DIFF')
					gvimdiff $1 <(gshow $hashes:$1)
					#TODO choose HEAD, WORKDIR, or other review, etc
					#TODO older_hash vs newer , or choose
					;;
				'MELD')
					set -x
					meld $1 <(gshow $hashes:$1)
					set +x
					;;
				'GREP')
					input -p 'Msg search' -v msgsearch && break
					;;
				'GGREP')
					input -p 'Code search' -v search && break
					;;
				*) ;;
			esac
		done
	done
	return 0 # $ret
}

function gfollow()
{
	local hash entries REPLY
	zparseopts -M -D - d=diff -diff=d
	gselect --follow "$@"
}

function gtag() #@TODO
{
	local tag hash
	echo TODO
	techo -c warn "Current tag: $(git describe --always --tags)" #$(git rev-list --tags --max-count=1)'
	return 1
	hash=${2:-$(gselect -h)}
	tag=$()
	git tag -a $tag $hash
}

function rebase_in_progress()
{
	[[ -d "$(git rev-parse --git-path rebase-merge 2>/dev/null)" || \
		-d "$(git rev-parse --git-path rebase-apply 2>/dev/null)" ]]
}

# git log --first-parent
function gmergebase()
{
	local common common2 _A _B
	#@TODO get "main" branch
	compare_to='master'
	#[[ -z $branch ]] && getbranch
	getbranch
	_A=${1:-$compare_to}
	_B=${2:-$branch}
	common=$(run -v3 git merge-base $_A $_B)
	common2=$(run -v3 git merge-base --fork-point $_A $_B 2>/dev/null)
	#[[ -n $common && $common != HEAD
	#@TODO show g log graphic with shared commits and fork-point
	if [[ -n $common || -n $common2 ]]; then
		if [[ -z $common2 || $common == $common2 ]]; then
			echo $common
		elif [[ -n $common ]]; then
			echo $common $common2
		fi
	else
		return 1
	fi
}

function grebase()
{
	local msg status cmd common _opts _from _onto
	zparseopts -D -M -A _opts - -onto:

	compare_to='master' #@TODO
	if ! rebase_in_progress; then
		_from=${1:-$compare_to}

		if [[ $_from != $compare_to ]] && ((!$+_opts[--onto])); then
			chooser -v _onto --head 'Rebase onto:' -f1 $compare_to $_from  || cancel
			_opts+=(--onto $_onto)
		fi

		#chooser -v branch -H 'Rebase branch' -S "$1" -b2- --ifs $'\n' "$(git branch)" || cancel
		getbranch || { techo -c warn 'No branches'; return 10 }
		#mergeHash=$(git rev-parse MERGE_HEAD)
		common=($(gmergebase $_from $branch))
		if (($#common > 1)); then
			integer n
			chooser -I n -v common -f1 --head 'Select base:' \
				$common[1] "$common[2] --fork-point" || cancel

			((n==2)) && _opts+=(--fork-point '')
			common=$common[n]
		fi

		glog $common..$branch
		# unstaged changes => g stash ?
		if confirm "Rebase ${(kv)_opts} $_from $branch"; then
			run git rebase ${(kv)_opts} $_from $branch
		else
			cancel
		fi

		rebase_in_progress || return 0
	fi

	# mergeHash=$(git rev-parse MERGE_HEAD)
	local unmerged=($(git diff --name-only --diff-filter=U))
	local events=(
		'A' 'Abort'
		'Q' 'Quit (abort but don'\''t reset HEAD)'
		'E|T' 'Edit (todo list)'
	)
	integer i
	#.git/rebase-merge/{msgnum,end}
	#e $VCS_STATUS_ACTION => rebase-i 1/2

	if [[ -n $1 ]]; then
		cmd=$1
	fi
	if (($#unmerged==0)); then # all resolved, enable continue
		opts+=('C' 'Continue')
	else
		local _disabled=("continue:Can't continue. There are conflicts to resolve.")
	fi

	if [[ -n $cmd ]]; then
		if [[ -z ${opts[(r)Rebase $cmd*]} ]]; then
			i=${_disabled[(i)$cmd:*]}
			if ((i<=$#_disabled)); then
				msg="$C[warn]Disabled command $C[lred]$cmd$C_: ${_disabled[$i]#$cmd:}"
			else
				msg="$C[warn]Invalid command: $C[lred]$cmd"
			fi
			cmd=
		fi
	fi

	if [[ -z $cmd ]]; then
		if (($#unmerged)); then
			local list=()
			for ((i=1; i<=$#unmerged; i++)); do
				list+=($i $unmerged[i])
			done
			chooser --head 'There are rebase conflicts in the following files:' \
				-f2 -v cmd --events "${(@q)events}" $list || cancel
		else
			chooser --head 'No conflicts' -f2 -v cmd --events "${(@q)events}" || cancel
		fi
	fi

	case $cmd in
		[Qq]uit)
			run git rebase --quit
		;;
		[Cc]ancel|[Aa]bort)
			run git rebase --abort
		;;
		finish|[Cc]ontinue|cont)
			run git rebase --continue
		;;
		edit|todo)
			run git rebase --edit-todo
		;;
		stat|status)
			local file
			#techo -c warn "Merge in progress (${mergeHash:0:8})"
			#unmerged=($(git ls-files --unmerged --abbrev=8))
			techo Needs merging: $unmerged
		;;
		*)
			return 1
		;;
	esac
}

comp+=(gmerge=gmerge)
function gmerge() #@TODO
{
	local mergeHash status unmerged cmd=$1
	(($#)) && shift || cmd='status'
	mergeHash=($(git rev-parse -q --verify MERGE_HEAD))
	if (($#mergeHash)); then
		case $cmd in
			cancel|abort) git merge --abort
			;;
			finish|commit|continue) git commit
			;;
			status)
				local file
				techo -c warn "Merge in progress (${mergeHash:0:8})"
				unmerged=($(git diff --name-only --diff-filter=U))
				#unmerged=($(git ls-files --unmerged))
				#chooser -v file -f1
				techo -c head "Needs merging: $C[warn]$unmerged"
			;;
		esac
	else
		# case $cmd in
		# 	status)
		# 	;;
		# esac
		local selection
		chooser -v selection -H 'Merge branch' -S "$1" --strip-color \
			-b3- --ifs $'\n' "$(listbranch -a)" || cancel

		selection=($=selection)

		confirm "Merge branch $selection" && run git merge $selection[1] --no-ff --no-commit
	fi
}

function ggrep() #@TODO
{
	local files pattern
	pattern=$(echo "$@" | awk -F' - ' '// {print $1}')
	files=$(echo "$@" | awk -F' - ' '// {print $2}')
	#pattern="${@%%_*}"
	#files="${@#*_}"
	#while arg in "$@"; do
	#    [[ "$arg" != "--" ]]
	#    [[ ]] && files+=" $arg"
	#done
	set -x
	git grep "$pattern" $(git rev-list --all -- ${=files}) -- ${=files}
	set +x
}

function commit() #@TODO
{
	local m args amend
	zparseopts -D -M - m:=m A=amend -amend=A
	[[ $amend[1] == '-A' ]] && amend='--amend'
	#@TODO check for empty changes
	if [[ -n "$1" && ${1:0:1} != - ]]; then
		m=(-m "$*")
	else
		args="$@"
	fi
	git commit $amend $m $args
}

function croot()
{
	git config --global --get alias.root > /dev/null || git config --global --add alias.root '!pwd'
	alias croot='cd $(git root)'
	cd $(git root)
}

# Added 2019-01-25 11:17:01
# https://github.com/search?q=
comp+=('github=cd')
function github()
{
	local url repo search echo forks
	zparseopts -D -M - r=repo s=search e=echo f=forks
	if (($#forks)); then
		repo="$*"
	fi

	if [[ $# -eq 0 ]]; then
		[[ -d "$(git rev-parse --git-dir 2>/dev/null)" ]] && github . || open 'https://github.com/'
	elif [[ -n $search ]]; then
		open "https://github.com/search?q=$(omz_urlencode $*)"
	elif [[ -n $repo ]]; then
		if (($#forks)); then
			open 'https://techgaun.github.io/active-forks/index.html#'$repo
		else
			url="https://github.com/$*"
			[[ -n $echo || ! -t 1 ]] && echo $url || open $url
		fi
	elif url=$(gitgetrepo "$*"); then
		if [[ -n $echo || ! -t 1 ]]; then
			echo $url
		elif [[ $url =~ '^git@github.com:(.*)/(.*)(.git)?$' ]]; then
			github -r $match[1]/$match[2]
		else
			open $url
		fi
	else
		githubrepo $echo "$@"
	fi
}

function githubAPI()
{
	local endpoint='https://api.github.com/graphql'
	local echo verbose args
	integer ret
	zparseopts -D -M - v=verbose

	request=${request//$'\n'/}
	#@TODO use curl wrapper
	response=$(curl -sS -H "Authorization: bearer $GITHUB_API_TOKEN" -X POST -d $request $endpoint)
	ret=$?
	type jq >/dev/null || chkCmd jq
	(($#verbose)) && {
		jq -r <<<$request
		jq -r <<<$response
	}

	if ((ret == 0)); then
		local field
		typeset -a rows tmp
		#while read -r field; do
		#	tmp+=("$(trim "$field")")
		#@TODO with raw, and trim is slow
		while read field; do
			tmp+=("$field")
			if (($#tmp == 5)); then
				repos+=("$tmp")
				tmp=()
			fi
		done < <(jq -cr "$fields" <<<$response)
	fi

	return $ret
}

function githubrepo()
{
	local limit=20 #request response fields
	local echo verbose args
	integer ret
	zparseopts -D -M - e=echo v=verbose

	args="${@%%.git}"

	request=$(cat) <<-GQL
	{
		"query":"query(\$search:String!,\$limit:Int!){
			search(query:\$search, first: \$limit, type: REPOSITORY){
				nodes {
				... on Repository {
					nameWithOwner, createdAt, updatedAt, stargazers { totalCount }, description
				}
				}
			}
		}",
		"variables":{ "search":"fork:true $args","limit":$limit }
	}
	GQL
	#	"variables":{ "search":"fork:true $(omz_urlencode "$*")","limit":$limit }
	fields='.data.search.nodes[] | .nameWithOwner,.createdAt[0:8],.updatedAt,.stargazers.totalCount,.description'
	githubAPI $request; ret=$?
	if ((ret == 0)); then
		local field
		typeset -a repos tmp
		#while read -r field; do
		#	tmp+=("$(trim "$field")")
		#@TODO with raw, and trim is slow
		while read field; do
			tmp+=("$field")
			if (($#tmp == 5)); then
				repos+=("$tmp")
				tmp=()
			fi
		done < <(jq -cr "$fields" <<<$response)

		if ((!$#repos)); then
			abort 10 'No repositories found'
		elif (($#repos == 1)); then
			github -r $echo $(explode "$repos" ' ' 1)
		else
			name=$(chooser -s' ' -f1 $repos "Open this search in github") || cancel
			if [[ $name == 'Open' ]]; then
				github -s "$*"
				abort 0
				return
			else
				github -r $echo $name
			fi
		fi
	fi
}

function gitgetrepo()
{
	local repo d remote
	zparseopts -D -M - d:=d
	(
		d=${d[2]:-"$*"}
		[[ -n $d ]] || d='.'
		if [[ -d $d ]]; then
			cd $d 2>/dev/null || {
				[ -t 1 ] && techo -c lred "Can't change to directory:$C_ $C[err]$d$C_"
				return 1
			}
		else
			[ -t 1 ] && techo -c lred "Directory not found:$C_ $C[err]$d$C_"
			return 1
		fi
		gremote || { [ -t 1 ] && techo -c warn 'No remotes'; return 10 }
		repo=$(git remote get-url $remote[1] 2>/dev/null) || {
			[ -t 1 ] && techo -c lred 'Git repository not found'
			return 1
		}
		[[ -n $repo ]] && echo $repo || {
			[ -t 1 ] && techo -c warn 'No remotes'
			return 10
		}
	)
	return $?
}

function gpush()
{
	local _opts
	zparseopts -M -D -A _opts - l=list -list=l 'f'
	if ! git push ${(@kv)_opts} "$@"; then
		remote=(${1:-$VCS_STATUS_REMOTE_NAME})
		if [[ -z $remote ]]; then
			gremote || { techo -c warn 'No remotes'; return 10 }
		fi
		branch=${2:-$VCS_STATUS_LOCAL_BRANCH}
		if [[ -z $branch ]]; then
			getbranch || { techo -c warn 'No branches'; return 10 }
		fi
		run git push --set-upstream ${(kv)_opts} $remote[1] $branch
		gpr
	fi
}

function getbranch()
{
	local tmp

	read -A tmp < $(git rev-parse --git-path ${1:-HEAD}) || return 1

	if (($#tmp>1)) && [[ $tmp[1] == 'ref:' ]]; then
		branch=$(git symbolic-ref --short ${1:-HEAD})
	elif (($#tmp)); then
		branch=$tmp
	else
		return 1
	fi
	techo -c head "Current branch: $C[warn]$branch"
}

function gswitch()
{
	local name cmd opt gopt out create force
	integer exists
	zparseopts -M -D -A opt - c=create f=force

	(($#)) && { name=$1; shift }
	if ((!$#name)); then
		#chooser 'New branch' $(lisbranch)
		gbranch -l
		input -p 'Branch' -v name || return
	fi
	gopt=($force)
	gbranch --exists $name && exists=1
	if ((!exists)); then
		if ((!$+opt[-c])); then
			confirm "No branch \"$name\" exists. Create it" || return
		fi
		gopt+=(-c)
	fi
	out=$(git switch $gopt $name 2>&1) && return
	techo -c warn $out
	return 1
}

function gbranch() #@TODO
{
	local list diff cmd get current opts
	zparseopts -M -D -A opts - d=diff -diff=d l=list -list=l c=create 'e' -exists=e

	#if (($#)) && [[ ${1:0:1} != '-' ]]; then

	#fi
	(($+opts[-e])) && {
		(($#1)) && git show-ref --verify --quiet refs/heads/$1
		return
	}
	cmd=($list $create)
	case $cmd in
		-c) #getbranch "$@" ;;
			gswitch -c "$@" ;;
		-l) listbranch "$@" ;;
		*) listbranch "$@" ;;
	esac
}

function listbranch()
{
	local _cols head merged to compare_to all _opts opts=()
	zparseopts -M -D -A _opts - -no-merged::=merged -merged::=merged a -all=a O:
	#zparseopts -M -D -A _opts - -no-merged::=N m:: -merged::=m 'a' -all=a O:
	#compare_to="$remote[1]/master"
	#@TODO get "main" branch
	compare_to='master'
	if (($+_opts[-a])); then
		opts+=(-a)
	else
		if (($+_opts[--no-merged])); then
			if (($#_opts[--no-merged])); then
				opts+=(--no-merged $_opts[--no-merged])
			else
				opts+=(--no-merged $compare_to)
			fi
		elif (($+_opts[--merged])); then
			if (($#_opts[--merged])); then
				opts+=(--merged $_opts[--no-merged])
			else
				opts+=(--merged $compare_to)
			fi
		else
			opts+=(--no-merged $compare_to)
		fi
	fi

	_cols=('refname' 'objectname' 'contents' 'committerdate')

	if (($+_opts[-O])); then
		_cols+=($=_opts[-O])
	fi

	[[ -n $_cols[(r)author] ]]
	#%(authorname)
	for tmp in $_cols; do

	done

	# format used in git-for-each-refonly
	glineFormat=(
		'%(HEAD)'
		'%(color:yellow)%(align:20,left)%(refname:short)%(end)%(color:reset)'
		'%(color:red)%(objectname:short)%(color:reset)'
		'%(color:reset)%(contents:subject)'
		'(%(color:green)%(committerdate:iso) %(color:#4579aa)%(committerdate:relative)%(color:reset))'
	)
	git --no-pager branch --sort=committerdate --format="$glineFormat" --color=always $opts "$@"
}
function gremote()
{
	#local current
	#zparseopts c=current

	remote=($(git remote))
}

# Added 2019-09-03 19:04
function gclone()
{
	local repo dir _opts base=$HOME/repos
	zparseopts -D -M -A _opts - b:

	include -r network
	repo=$1 ; dir=$2
	(($+_opts[-b])) && base=$_opts[-b]
	cd $base

	{ [[ -n "$(urlinfo -s $repo)" ]] || repo="$(github -e $repo)" } || return

	while ((1)); do
		if [[ -z $dir ]]; then
			dir=${repo##*/}
			dir=${dir%%.git}
			if [[ -d $dir ]]; then
				local name=()
				urlinfo -v name -p $repo
				dir=${${name[1]#/*}/\//_}
			fi
			input -p $repo -t 'Clone into dir' -v dir $dir || return
		fi
		if git clone $repo $dir && [[ -d $dir ]] && cd $dir; then
			return 0
		fi
		techo -c lred Error cloning $repo
		confirm 'Try again' || return 1
	done
}

function gpr()
{
	#local request owner
	local owner url dir _opts base=$HOME/repos
	zparseopts -D -M -A _opts - b: 'f'

	(($+_opts[-f])) || confirm 'Open Pull Request' || return

	if url=$(gitgetrepo "$*"); then
		local args=($(urlinfo -hp $url))
		open "https://$args[1]/$args[2]/pull/new/$branch"
	else
	fi

	return

	request=$(cat) <<-GQL
	{
	"query":query(owner:"$owner", name:"$repname") {
	  repository(owner:"$owner", name:"$repname") {
		pullRequests(states:[OPEN]) {
		  nodes {
			... on PullRequest {
			  id, author { login }, createdAt
			  merged, mergedAt, mergeable
			  body, changedFiles
			  commits(first: 100) {
				nodes { commit {
					oid
					message
					status { context(name: "x") { description } }
				  } }
			  }
			  comments(last: 100) {
				nodes { author { login }, updatedAt, minimizedReason }
			  }
			  labels(last: 100) {
				nodes {
				  ... on Label { color, name, description }
				}
			  }
			}
		  }
		}
	  },
	}
	"variables":{ "search":"fork:true $*","limit":$limit }
	}
	GQL

	githubAPI -v prs $request; ret=$?
	if ((ret == 0)); then
		if ((!$#prs)); then
			abort 10 'No Pull Requests found'
		else
			chooser -v pr "$prs[@]"
		fi
	fi

#{
#	"query":query(owner:"$owner", name:"$repname") {
#	  repository(owner:"$owner", name:"$repname") {
#		pullRequests(first: 10, states: OPEN, orderBy: {field: UPDATED_AT, direction: DESC}) {
#		  nodes {
#			... on PullRequest {
#			  id, author { login }, createdAt
#			  merged, mergedAt, mergeable
#			  body, changedFiles
#			  commits(first: 100) {
#				nodes { commit {
#					oid
#					message
#					status { context(name: "x") { description } }
#				  } }
#			  }
#			  comments(last: 100) {
#				nodes { author { login }, updatedAt, minimizedReason }
#			  }
#			  labels(last: 100) {
#				nodes {
#				  ... on Label { color, name, description }
#				}
#			  }
#			}
#		  }
#		}
#	  },
#	}
#	"variables":{ "search":"fork:true $*","limit":$limit }
#}
#query { organization(login: "MyOrganisation") {
#		  repositories(first: 20, orderBy: {field: PUSHED_AT, direction: DESC}) {
#		  nodes {
#			  name
#			  pullRequests(first: 10, states: OPEN, orderBy: {field: UPDATED_AT, direction: DESC}) {
#				  nodes {
#					  headRepository { nameWithOwner }
#					  url
#					  author {
#					  ... on User {
#						  login name
#						  }
#					  }
#					  mergeable
#					  createdAt
#					  baseRefName
#					  headRefName
#					  title
#					  ... on PullRequest {
#						  pullRequestcommits: commits(last: 1) {
#							  totalCount
#							  nodes {
#								  commit {
#									  url
#									  status { state contexts { context description createdAt targetUrl } }
#								  }
#							  }
#						  }
#					  }
#				  }
#			  }
#		  }
#	  }
#	}
#  }
}

# Added 2019-12-04 18:50
function gbisect()
{
	cmd=$1
	case $bisectState in
		running)
			;;
		'')
			;;
	esac
}

# Added 2020-3-28 21:27
#search changes of string: -Sstring
#--ignore-space-at-eol -b -w --ignore-blank-lines --minimal
comp+=('gdiff=git-diff')
function gdiff()
{
	local cmd _opts _dopts flist
	zparseopts -D -M -A _opts - 'i' -interactive=i 'l' -list=l \
		's' -staged=s

	_dopts=()
	(($+_opts[-s])) && _dopts+=(--staged)

	if  (($+_opts[-i])); then
		local f name _copts args _a _b head_hash hashes2=() hashes=()
		integer idx h i sepgiven
		i=${@[(ie)--]}
		if ((i<=$#)); then # "--" given
			#hashes=("$@[1,i-1]")
			#shift $#hashes
			sepgiven=1
		fi

		#
		j=1
		while [[ $j -lt $i && (
			$sepgiven -gt 0 || ( ! -f $@[j] && ! -d $@[j] ) #&& isRevision rev-parse)
		) ]]
		do
			if [[ ${@[j]:0:1} == '-' ]]; then
				_dopts+=($@[j])
				shift
				((i--))
			else
				((j++))
			fi
		done
		hashes=("$@[1,j-1]")
		shift $#hashes
		((sepgiven)) && shift # shift the "--" sep
		args=("$@")
		# --relative
		flist=($(git diff --no-color --name-only $_dopts $hashes -- "$args[@]")) || return

		(($#flist==0)) && { techo -c warn 'No differences'; return }

		if [[ "$hashes" =~ ^([^. ]*)([ .]\+)?([^. ]*)$ ]]; then
			techo -r h1="'$match[1]'" h2="'$match[2]'" h3="'$match[3]'"
			if [[ -n $match[2] ]]; then
				hashes=(${match[1]:-HEAD} ${match[3]:-HEAD})
				if [[ $match[2] == '...' ]]; then
					hashes[1]="$(git merge-base $hashes[@])"
				fi
				_a=$hashes[1]
				_b=$hashes[2]
			elif [[ -n $match[1] ]]; then
				hashes=($match[1])
				_a=$hashes[1]
				if (($+_opts[-s])); then #staged
					_b='INDEX'		# commit => index
				else
					_b='WORKDIR'	# commit => workdir
				fi
			elif (($+_opts[-s])); then
				_a='WORKDIR'		# disk => index
				_b='INDEX'
			else
				_a='HEAD'		# head => disk
				_b='WORKDIR'
			fi
			# hashes2=($(git rev-parse $hashes))
			# head_hash="$(git rev-parse HEAD)"
			#if in_array -v h $head_hash hashes2; then
			#	$hashes
			#fi
		else
			abort -v5 -d-1 2 "Incorrect arguments: $hashes"
		fi

		_copts=(
			--head "Diff $_dopts $hashes" -I 'idx' -v 'f'
			--foot '(Enter) Show diff in terminal  (V or E) Gvimdiff  (M) Meld (C) VS Code (R) Restore (U) Unstage (Esc) Quit'
			--events "[ve] EDIT m MELD c VSCODE r RESTORE u UNSTAGE" --no-auto-select
		)
		# --src-prefix=
		# Show the given source prefix instead of "a/".
		# --dst-prefix=<prefix>
		while chooser -D $idx $_copts $flist; do
			cmd=()
			case $ACTION in
				'')
					(($+_opts[-s])) && C2=$C[lcyan]
					techo "$cmd {$C[warn]$_a$_C => $C2$_b$C_}:$f"
					run git diff --src-prefix=$_a/ --dst-prefix=$_b/ $_dopts "$hashes[@]" -- $f
				;;
				'EDIT')
					cmd=(gvimdiff -f)
				;;
				'MELD')
					cmd=(meld)
				;;
				'RESTORE')
					grestore $f
				;;
				'UNSTAGE')
					gunstage $f
				;;
				'VSCODE')
					code $f
					#cmd=(code)
				;;
			esac

			if (($#cmd)); then
				if (($#hashes == 0)); then
					if (($+_opts[-s])); then
						# workdir => index
						C1=$C[warn] ; C2=$C[lcyan]
						techo "$cmd {$C1$_a $C[lcyan]=> $C2$_b$C_}:$f"
						$cmd <(git show HEAD:$f) <(git show :$f)
					else
						# head => workdir
						C1=$C[lred] ; C2=$C[warn]
						techo "$cmd {$C1$_a $C[lcyan]=> $C2$_b$C_}:$f"
						$cmd <(gshow HEAD:$f) $f
					fi
				elif (($#hashes == 1)); then
					if (($+_opts[-s])); then
						# commit <=> index
						C1=$C[lred] ; C2=$C[lcyan]
						techo "$cmd {$C1$_a $C[lcyan]=> $C2$_b$C_}:$f"
						$cmd <(gshow $hashes[1]:$f) <(git show :$f)
					else
						# commit <=> workdir
						C1=$C[lred] ; C2=$C[warn]
						techo "$cmd {$C1$_a $C[lcyan]=> $C2$_b$C_}:$f"
						$cmd <(gshow $hashes[1]:$f) $f
					fi
				else
					C1=$C[warn] ; C2=$C[ok]
					techo "$cmd {$C1$_a $C[lcyan]=> $C2$_b$C_}:$f"
					$cmd <(gshow $hashes[1]:$f) <(gshow $hashes[2]:$f)
				fi
			fi
		done
		#for f in $flist; do
			#techo ${(q)f}
			#$cmd "$f"
			#confirm 'Compare' || continue
			#name=$(getfilename $f)
			#tmp=$TMPDIR/$name
			#gshow account_manager:$f > $tmp
			#meld $tmp "$f"
		#done
	else
		(($+_opts[-l])) && _dopts+=('--name-only')
		git diff $_dopts "$@"
	fi
}

function gstatus()
{
	local _gopts _opts buf line _vname _gst stat fn f
	local dev_diff staged changed diff_changed_dev
	integer n=10 i
	zparseopts -D -M -A _opts -
	#TODO gselect
	#flist=($(git status -uno --porcelain=v2 $_dopts $hashes -- "$args[@]")) || return
	git status -uno --short "$@"
	return
	_gst=($(git status -uno --short "$@"))
	for stat f in $_gst; do
		fn=${f%.js}

		staged="$(git diff --staged $f)"
		changed="$(git diff --color=never $f)"
		dev_diff=''
		#diff_changed_dev=''
		if [[ -f $fn.dev.js ]]; then
			dev_diff=$(diff -u --color=never $fn.dev.js $f)
		#	if (($#changed && $#dev_diff)); then
		#		diff_changed_dev=$(diff -u <(<<<"$changed") <(<<<"$dev_diff"))
		#		(f - git)
		#		#e $changed $dev_diff
		#	fi
		fi
		#diff_stg_dev = changed_ - changes_in_.dev  # $#diff_stg_dev
		techo $stat $f $#dev_diff #$(($#changed - $#dev_diff)) $diff_changed_dev
	done

}

gFormat=(
	'%h'		# short hash
	'%<(3,trunc)%cn' # author
	'%C(auto)%d%Creset'		# ref names
	'%s'			# subject
	'(%Cgreen%ci %C(#4579aa)%cr%Creset)' # date
)
# Added 2020-04-06 16:43
alias _glog='git log'
comp+=('glog=_glog')
function glog()
{
	local _gopts _opts buf line _vname hashP authorP refsP subjectP dateP
	local aline author
	integer n=10 i
	zparseopts -D -M -A _opts - -date: 'r' -relative=r v: 'l' n:

	_gopts=(--graph --color=always --format=tformat:"$gFormat")
	(($+_opts[-r])) && _gopts+=(--relative)
	(($+_opts[-n])) && n=$_opts[-n]
	_gopts+=(-n $n)

	if [[ -n $_opts[-v] ]]; then
		_vname=$_opts[-v]
		typeset -ga $_vname
	fi

	hashP='[a-f0-9]{5,}'
	authorP='[A-Z]'
	refsP='\(.*\)'
	subjectP='.*'
	dateP='\(.*\)'
	typeset -A authorColor=('E' yellow 'P' warn '*' lcyan)
	lcolors=('' yellow '' '' '')
	while read -r line; do
		((i++))
		# _glsub=(¬P.. "$C[warn]P$C_" ¬E.. "$C[ok]$EC_")
		if [[ $line =~ '(.*) ('$~hashP') ('$~authorP').. ('$~refs')? ?('$subjectP') ('$~dateP')' ]]
		then
			#author=$match[3]
			#color=$C[$authorColor[$author]]
			#match[3]=$color$author$C_
			#match[2]=$colo
			#TODO save colors and data in separated arrays
			aline="$match"
		else
			aline="$line"
		fi

		if [[ -n $_vname ]]; then
			typeset -g "${_vname}[$i]=\"$aline\""
		else
			echo -E - "$aline"
		fi
	done < <(git log --date=${_opts[--date]:-iso} $_gopts "$@")
}

# Added 2020-04-29 14:25
function gstash()
{
	local _gopts cmd
	#zparseopts -D -M -A _opts - -date:
	# --date=${_opts[--date]:-iso}
	_gopts=(--color=always --format=tformat:"$gFormat")

	if (($#==0)); then
		cmd='list'
	else
		cmd=$1
		shift
	fi

	case $cmd in
		list)
			_gopts+=(--dirstat)
			run -v3 git stash list $_gopts "$@"
			;;
		show)
			run -v3 git stash show $_gopts "$@"
			;;
		'')
			;;
	esac
}

# Added 2020-04-20 00:46
function gexpirestash()
{
	local when='30.days'
	input -p 'Expire before' -v when || return
	[[ -n $when ]] && run git reflog expire --expire=$when refs/stash
}

# confirm first to discard changes not saved in stash or some other place
# call this from gst -i
function grestore()
{
	local files
	((!$#)) && gst

	git restore "$@"
}
#TODO unstage error: pathspec '.*' did not match any file(s) known to git
#gpick() { e TODO .git/CHERRY_PICK_HEAD }
#gstash() {
  #TODO: -R: git stash show stash@\{0\} -p | git apply -R
#}

# Added 2020-07-19 23:56
function jira() {
	#TODO infere board from git repofunction jira() {
	#TODO infere board from git repo
	#TODO list issues, default filters: sprint=current AND (!assignee OR assignee=me) AND status<>Done
	#chooser Start task
	input -v issueId -p 'Issue id' || return
	# TODO: suggest branch name from issue id
	repo=$(gitgetrepo)
	repoPrefix=${(L)repo##*/}
	bName="feat/$repoPrefix-$issueId-"
	input -v bName -p 'Branch name'
	[[ $bName =~ feat/$repoPrefix-([0-9]##) && $match[1] -eq $issueId ]] || abort 2 "Incorrect branch name. Must start with \"feat/$repoPrefix-$issueId-\""
	gbranch -c $bName || return
	# TODO: set assignee=me; set status=InProgress

}

