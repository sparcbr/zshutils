VERSION=1.0.5
#lazyload=gdiff,gclone,gpr,commit,github,gpush,croot,gfollow,gunstage,gmerge,gchk,gbranch,grebase,gshow
alias pull="git pull"
alias push="gpush"
alias gadd="git add"
alias gadd-modified="git add \$(git diff --name-only --relative)"
alias gh='github'
alias unstage="gunstage"
alias git_get_tag='git describe --tags $(git rev-list --tags --max-count=1)'
alias glog2='git log --date=iso -g'
alias gd='gdiff'
alias gdi='gdiff --interactive'

export github_token='b2e74253b94398066f3938bb63120f51ca7745ee'

[[ ! -v comp ]] && typeset -g -a comp

#if [[ -z $PAGER && -z $GITPAGER ]]; then
#	chooser -v PAGER -f1 'less' 'bat' '- *no pager*'
#	[[ $PAGER == '-' ]] && PAGER=''
#fi

function gshow()
{
	local _opts gopts=()
	zparseopts -D -M -A _opts - l -list=l

	(($+_opts[-l])) && gopts=('--name-only')

	git show $gopts "$@"
}

comp+=('gchk=git')
function gchk()
{
	git checkout "$@" && git status
}

comp+=('gunstage=git')
function gunstage()
{
	git restore --staged "$@"
}

function gselect()
{
	local lines _opts gopts noSelect
	integer ret i idx nlimit=30
	setopt extendedglob
	#zparseopts -D -M -A _opts - #-all
	#opts="$@"
	gopts=(
		--color=always --graph -n $nlimit
		--format=format:'%h %an <%aE> %ai %f'
	)

	while [[ ${1[1]} == '-' ]]; do
		if [[ $1 == '-' || $1 == '--' ]]; then
			shift
			break
		fi
		gopts+=("$1")
		shift
	done

	lines=("$(run git log $gopts "$@")")

	# mark lines without content as non-selectable
	for ((i=1; i<=$#lines; i++)); do
		if [[ ! $lines[i] =~ [a-f0-9]{5,} ]]; then
			noSelect+=($i)
		fi
	done
	(($#noSelect)) && _opts+=(-n "$noSelect")

	_opts=(
		#--head 'Commits containing "$1"'
		--foot '(Enter) Show in terminal (V or E) Vim (F) Full revision (D) Diff (M) Meld (Q) Quit. Do nothing.'
		--events "v\\|e EDIT f FULL d DIFF m MELD" 
		-I idx
	)
	
	if ((${lines[(i)--follow]}<$#lines)); then
		_opts+=(--head "Following $@")
	fi

	while { chooser --simple -v hashes --ifs $'\n' \
		-R '([a-f0-9]{5,40} .*)' -f1 -D $idx $_opts $lines ; ret=$? ; ((ret==0)) }
	do
		case $ACTION in
			'')
				gshow $hashes $1
				;;
			'EDIT')
				gshow $hashes $1 | gvim -
				;;
			'FULL')
				gshow $hashes:$1 | gvim -
				;;
			'DIFF')
				gvimdiff $1 <(gshow $hashes:$1)
				;;
			'MELD')
				meld $1 <(gshow $hashes:$1)
				;;
		esac
	done
	return $ret
}

function gfollow()
{
	local hash entries REPLY
	zparseopts -M -D - d=diff -diff=d
	gselect --follow "$@"
	#hashes=($(egrep '^commit' <(git log --follow "$@") | awk '{print $2}'))
	#entries=("${(@f)$(git log --format=format:%h\ %an\ \<%aE\>\ %ai\ %f --follow $1)}")
}

function gtag() #@TODO
{
	local tag hash
	echo TODO
	return 1
	hash=${2:-$(gselect -h)}
	tag=$()
	git tag -a $tag $hash
}

function rebase_in_progress()
{
	[[ -d "$(git rev-parse --git-path rebase-merge 2>/dev/null)" || \
		-d "$(git rev-parse --git-path rebase-apply 2>/dev/null)" ]]
}

function gconfig()
{
	# 'color.ui' 'auto'
	#git config --global $opt $val
}
# git log --first-parent 
function gmergebase()
{
	local common common2 _A _B
	#@TODO get "main" branch
	compare_to='master'
	#[[ -z $branch ]] && getbranch
	getbranch
	_A=${1:-$compare_to}
	_B=${2:-$branch}
	common=$(run git merge-base $_A $_B) 
	common2=$(run git merge-base --fork-point $_A $_B 2>/dev/null)
	#[[ -n $common && $common != HEAD
	#@TODO show glog graphic with shared commits and fork-point
	if [[ -n $common || -n $common2 ]]; then
		if [[ -z $common2 || $common == $common2 ]]; then
			echo $common
		elif [[ -n $common ]]; then
			echo $common $common2
		fi
	else
		return 1
	fi
}

function grebase()
{
	local msg status cmd common _opts _from _onto
	zparseopts -D -M -A _opts - i -onto:
	compare_to='master' #@TODO
	if ! rebase_in_progress; then
		_from=${1:-$compare_to}

		if [[ $_from != $compare_to ]] && ((!$+_opts[--onto])); then
			chooser -v _onto --head 'Rebase onto:' -f1 --simple $compare_to $_from  || cancel
			_opts+=(--onto $_onto)
		fi

		#chooser -v branch -H 'Rebase branch' -S "$1" -b2- --ifs $'\n' "$(git branch)" || cancel
		getbranch || { techo -c warn 'No branches'; return 10 }
		#mergeHash=$(git rev-parse MERGE_HEAD)
		common=($(gmergebase $_from $branch))
		if (($#common > 1)); then
			integer n
			chooser -I n -v common -f1 --head 'Select base:' --simple \
				$common[1] "$common[2] --fork-point" || cancel

			((n==2)) && _opts+=(--fork-point '')
			common=$common[n]
		fi

		glog $common..$branch
		# unstaged changes => g stash ?
		if confirm "Rebase ${(kv)_opts} $_from $branch"; then
			run git rebase ${(kv)_opts} $_from $branch
		else
			cancel
		fi
		
		rebase_in_progress || return 0
	fi

	# mergeHash=$(git rev-parse MERGE_HEAD)
	local unmerged=($(git diff --name-only --diff-filter=U))
	local events=(
		'A' 'Abort'
		'Q' 'Quit (abort but don'\''t reset HEAD)'
		'E|T' 'Edit (todo list)'
	)
	integer i
	#.git/rebase-merge/{msgnum,end}
	#e $VCS_STATUS_ACTION => rebase-i 1/2

	if [[ -n $1 ]]; then
		cmd=$1
	fi
	if (($#unmerged==0)); then # all resolved, enable continue
		opts+=('C' 'Continue')
	else
		local _disabled=("continue:Can't continue. There are conflicts to resolve.")
	fi

	if [[ -n $cmd ]]; then
		if [[ -z ${opts[(r)Rebase $cmd*]} ]]; then
			i=${_disabled[(i)$cmd:*]}
			if ((i<=$#_disabled)); then
				msg="$C[warn]Disabled command $C[lred]$cmd$C_: ${_disabled[$i]#$cmd:}"
			else
				msg="$C[warn]Invalid command: $C[lred]$cmd"
			fi
			cmd=
		fi
	fi
	
	if [[ -z $cmd ]]; then
		if (($#unmerged)); then
			local list=()
			for ((i=1; i<=$#unmerged; i++)); do
				list+=($i $unmerged[i])
			done
			chooser --head 'There are rebase conflicts in the following files:' \
				--simple -f2 -v cmd --events "${(@q)events}" $list || cancel
		else
			chooser --head 'No conflicts' --simple -f2 -v cmd --events "${(@q)events}" || cancel
		fi
	fi

	case $cmd in
		[Qq]uit)
			run git rebase --quit
		;;
		[Cc]ancel|[Aa]bort)
			run git rebase --abort
		;;
		finish|[Cc]ontinue|cont)
			run git rebase --continue
		;;
		edit|todo)
			run git rebase --edit-todo
		;;
		stat|status)
			local file
			#techo -c warn "Merge in progress (${mergeHash:0:8})"
			#unmerged=($(git ls-files --unmerged --abbrev=8))
			techo Needs merging: $unmerged
		;;
		*)
			return 1
		;;
	esac
}

function gmerge() #@TODO
{
	local mergeHash status unmerged cmd=$1
	(($#)) && shift || cmd='status'
	mergeHash=($(git rev-parse -q --verify MERGE_HEAD))
	if (($#mergeHash)); then
		case $cmd in
			cancel|abort) git merge --abort
			;;
			finish|commit|continue) git commit
			;;
			status)
				local file
				techo -c warn "Merge in progress (${mergeHash:0:8})"
				unmerged=($(git diff --name-only --diff-filter=U))
				#unmerged=($(git ls-files --unmerged))
				#chooser -v file -f1 
				techo -c head "Needs merging: $C[warn]$unmerged"
			;;
		esac
	else
		# case $cmd in
		# 	status)
		# 	;;
		# esac
		local selection
		chooser -v selection -H 'Merge branch' -S "$1" --strip-color \
			-b3- --ifs $'\n' "$(listbranch -a)" || cancel

		selection=($=selection)
		
		confirm "Merge branch $selection" && run git merge $selection[1] --no-ff --no-commit
	fi
}

function ggrep() #@TODO
{
	local files pattern
	pattern=$(echo "$@" | awk -F' - ' '// {print $1}')
	files=$(echo "$@" | awk -F' - ' '// {print $2}')
	#pattern="${@%%_*}"
	#files="${@#*_}"
	#while arg in "$@"; do
	#    [[ "$arg" != "--" ]]
	#    [[ ]] && files+=" $arg"
	#done
	set -x
	git grep "$pattern" $(git rev-list --all -- ${=files}) -- ${=files}
	set +x
}

function commit() #@TODO
{
	local m args amend
	zparseopts -D -M - m:=m A=amend -amend=A
	[[ $amend[1] == '-A' ]] && amend='--amend'
	#@TODO check for empty changes
	if [[ -n "$1" && ${1:0:1} != - ]]; then
		m=(-m "$*")
	else
		args="$@"
	fi
	git commit $amend $m $args
}

function croot()
{
	git config --global --get alias.root > /dev/null || git config --global --add alias.root '!pwd'
	alias croot='cd $(git root)'
	cd $(git root)
}

# Added 2019-01-25 11:17:01
# https://github.com/search?q=
comp+=('github=cd')
function github()
{
	local url repo search echo
	zparseopts -D -M - r=repo s=search e=echo
	if [[ $# -eq 0 ]]; then
		[[ -d "$(git rev-parse --git-dir 2>/dev/null)" ]] && github . || open 'https://github.com/'
	elif [[ -n $search ]]; then
		open "https://github.com/search?q=$(omz_urlencode $*)"
	elif [[ -n $repo ]]; then
		url="https://github.com/$*"
		[[ -n $echo || ! -t 1 ]] && echo $url || open $url
	elif url=$(gitgetrepo "$*"); then
		if [[ -n $echo || ! -t 1 ]]; then
			echo $url
		elif [[ $url =~ '^git@github.com:(.*)/(.*)(.git)?$' ]]; then
			github -r $match[1]/$match[2]
		else
			open $url
		fi
	else
		githubAPI $echo "$@"
	fi
}

function githubAPI()
{
	local limit=20 endpoint='https://api.github.com/graphql' #request response fields
	local echo verbose ret args
	zparseopts -D -M - e=echo v=verbose

	args="${@%%.git}"

	request=$(cat) <<-GQL
	{ 
		"query":"query(\$search:String!,\$limit:Int!){
			search(query:\$search, first: \$limit, type: REPOSITORY){
				nodes {
				... on Repository {
					nameWithOwner, createdAt, updatedAt, stargazers { totalCount }, description
				}
				}
			}
		}",
		"variables":{ "search":"fork:true $args","limit":$limit }
	}
	GQL
	#	"variables":{ "search":"fork:true $(omz_urlencode "$*")","limit":$limit }
	fields='.data.search.nodes[] | .nameWithOwner,.createdAt[0:8],.updatedAt,.stargazers.totalCount,.description'
	request=${request//$'\n'/}
	response=$(curl -sS -H "Authorization: bearer $GITHUB_API_TOKEN" -X POST -d $request $endpoint)
	ret=$?
	type jq >/dev/null || chkCmd jq 
	(($#verbose)) && {
		jq -r <<<$request
		jq -r <<<$response
	}
	if ((ret == 0)); then
		local field
		typeset -a repos tmp
		#while read -r field; do
		#	tmp+=("$(trim "$field")")
		#@TODO with raw, and trim is slow
		while read field; do
			tmp+=("$field")
			if (($#tmp == 5)); then
				repos+=("$tmp")
				tmp=()
			fi
		done < <(jq -cr "$fields" <<<$response)

		if ((!$#repos)); then
			abort 10 'No repositories found'
		elif (($#repos == 1)); then
			github -r $echo $(explode "$repos" ' ' 1)
		else
			name=$(chooser -s' ' -f1 $repos "Open this search in github") || cancel
			if [[ $name == 'Open' ]]; then
				github -s "$*"
				abort 0
				return 
			else
				github -r $echo $name
			fi
		fi
	fi
}

function gitgetrepo()
{
	local repo d remote
	zparseopts -D -M - d:=d
	(
		d=${d[2]:-"$*"}
		[[ -n $d ]] || d='.'
		if [[ -d $d ]]; then
			cd $d 2>/dev/null || {
				[ -t 1 ] && techo -c lred "Can't change to directory:$C_ $C[err]$d$C_"
				return 1
			}
		else
			[ -t 1 ] && techo -c lred "Directory not found:$C_ $C[err]$d$C_"
			return 1
		fi
		gremote || { [ -t 1 ] && techo -c warn 'No remotes'; return 10 }
		repo=$(git remote get-url $remote[1] 2>/dev/null) || {
			[ -t 1 ] && techo -c lred 'Git repository not found'
			return 1
		}
		[[ -n $repo ]] && echo $repo || {
			[ -t 1 ] && techo -c warn 'No remotes'
			return 10
		}
	)
	return $?
}

function gpush()
{
	if ! git push "$@"; then
		remote=(${1:-$VCS_STATUS_REMOTE_NAME})
		if [[ -z $remote ]]; then
			gremote || { techo -c warn 'No remotes'; return 10 }
		fi
		branch=${2:-$VCS_STATUS_LOCAL_BRANCH}
		if [[ -z $branch ]]; then
			getbranch || { techo -c warn 'No branches'; return 10 }
		fi
		git push --set-upstream $remote[1] $branch
	fi
}

function getbranch()
{
	local tmp

	read -A tmp < $(git rev-parse --git-path ${1:-HEAD}) || return 1
	
	if (($#tmp>1)) && [[ $tmp[1] == 'ref:' ]]; then
		branch=$(git symbolic-ref --short ${1:-HEAD})
	elif (($#tmp)); then
		branch=$tmp
	else
		return 1
	fi
	techo -c head "Current branch: $C[warn]$branch"
}

function gbranch() #@TODO
{
	local list diff cmd get current
	zparseopts -M -D - d=diff -diff=d l=list -list=l c=current

	cmd=($list $current)
	case $cmd in
		-c) getbranch "$@" ;;
		-l) listbranch "$@" ;;
		*) listbranch "$@" ;; 
	esac
}

typeset -A gFields=(
	'HEAD' ''
	'refname:s' 'yellow'
	'objectname:s' 'red'
	'contents:subject' 'magenta'
	'committerdate' 'green' 
)

#only works for git log --format?
	glineFormat=(
		'%(HEAD)'
		'%C(yellow)%(refname:short)%Creset'
		'%C(red)%(objectname:short)%Creset'
		'%C(magenta)%(contents:subject)%Creset'
		'(%C(green)%(committerdate:relative)%Creset)'
	)
function listbranch()
{
	local _cols head merged to compare_to all _opts opts=()
	zparseopts -M -D -A _opts - -no-merged::=merged -merged::=merged a=all O:
	#compare_to="$remote[1]/master"
	#@TODO get "main" branch
	compare_to='master'
	if (($#all)); then
	
	else
		if (($+_opts[--no-merged])); then
			if (($#_opts[--no-merged])); then
				opts+=(--no-merged $_opts[--no-merged])
			else
				opts+=(--no-merged $compare_to)
			fi
		elif (($+_opts[--merged])); then
			if (($#_opts[--merged])); then
				opts+=(--merged $_opts[--no-merged])
			else
				opts+=(--merged $compare_to)
			fi
		else
			opts+=(--no-merged $compare_to)
		fi
	fi
	
	_cols=('refname' 'objectname' 'contents' 'committerdate')

	if (($+_opts[-O])); then
		_cols+=($=_opts[-O])
	fi

	[[ -n $_cols[(r)author] ]]
	#%(authorname)
	for tmp in $_cols; do

	done
	glineFormat=(
		'%(HEAD)'
		'%(color:yellow)%(refname:short)%(color:reset)'
		'%(color:red)%(objectname:short)%(color:reset)'
		'%(color:magenta)%(contents:subject)%(color:reset)'
		'(%(color:green)%(committerdate:relative)%(color:reset))'
	)
	git --no-pager branch --sort=committerdate --format="$glineFormat" --color=always $opts "$@"
}
function gremote()
{
	#local current
	#zparseopts c=current
	
	remote=($(git remote))
}

# Added 2019-09-03 19:04
function gclone()
{
	local repo dir

	include -r network
	repo=$1 ; dir=$2
	cd $HOME/repos

	{ [[ -n "$(urlinfo -s $repo)" ]] || repo="$(github -e $repo)" } || return

	while ((1)); do
		if [[ -z $dir ]]; then
			dir=${repo##*/}
			dir=${dir%%.git}
			if [[ -d $dir ]]; then
				local name=()
				urlinfo -v name -p $repo
				dir=${${name[1]#/*}/\//_}
			fi
			input -p $repo -t 'Clone into dir' -v dir $dir || return
		fi
		if git clone $repo $dir && [[ -d $dir ]] && cd $dir; then
			return 0
		fi
		techo -c lred Error cloning $repo
		confirm 'Try again' || return 1
	done
}

function gpr()
{
	local request owner 

	request=$(cat) <<-GQL
	{
	"query":query(owner:"$owner", name:"$repname") {
	  repository(owner:"$owner", name:"$repname") {
		pullRequests(states:[OPEN]) {
		  nodes {
			... on PullRequest {
			  id, author { login }, createdAt
			  merged, mergedAt, mergeable
			  body, changedFiles
			  commits(first: 100) {
				nodes { commit {
					oid
					message
					status { context(name: "x") { description } }
				  } }
			  }
			  comments(last: 100) {
				nodes { author { login }, updatedAt, minimizedReason }
			  }
			  labels(last: 100) {
				nodes {
				  ... on Label { color, name, description }
				}
			  }
			}
		  }
		}
	  },
	}
	"variables":{ "search":"fork:true $*","limit":$limit }
	}
	GQL
}

# Added 2019-12-04 18:50
function gbisect()
{
	cmd=$1
	case $bisectState in
		running)
			;;
		'')
			;;
	esac
}

# Added 2020-3-28 21:27
#search changes of string: -Sstring
#--ignore-space-at-eol -b -w --ignore-blank-lines --minimal
comp+=('gdiff=git-diff')
function gdiff()
{
	local cmd _opts flist
	zparseopts -D -M -A _opts - i -interactive=i

	if  (($+_opts[-i])); then
		local f name _copts args head_hash hashes2=() hashes=()
		integer idx h
		#hash=$1
		#shift
		_copts=(
			--head "diff $*"
			--foot '(Enter) Show in terminal (V or E) Gvimdiff (M) Meld (Esc) Quit'
			--events "v\\|e EDIT m MELD" 
			-I idx
			--no-auto-select
		)
		
		#flist=($(git diff --no-color --name-only $hash "$@"))
		flist=($(git diff --no-color --name-only "$@")) || return $?

		if [[ "$*" =~ ^([^. ]*)([ .]\+)?([^. ]*)$ ]]; then
			if [[ -n $match[2] ]]; then
				hashes=(${match[1]:-HEAD} ${match[2]:-HEAD})
			elif [[ -n $match[1] ]]; then
				# workdir <-> commit
				hashes=($match[1])
			else
				#abort -v5 -d-1 1 "Incorrect arguments: $@"
			fi
			hashes2=($(git rev-parse $hashes))
			head_hash="$(git rev-parse HEAD)"
			#if in_array -v h $head_hash hashes2; then
			#	$hashes
			#fi
		else
			abort -v5 -d-1 2 "Incorrect arguments: $@"
		fi

		while chooser --simple -v f -D $idx $_copts $flist
		do
			cmd=''
			case $ACTION in
				'')
					git diff "$@" -- $f
				;;
				'DIFF')
					cmd='gvimdiff'
				;;
				'MELD')
					cmd='meld'
				;;
			esac

			if [[ -n $cmd ]]; then
				if (($#hashes == 0)); then
				elif (($#hashes == 1)); then
					$cmd <(gshow $hashes[1]:$f) $f
				else
					$cmd <(gshow $hashes[1]:$f) <(gshow $hashes[2]:$f)
				fi
			fi
		done
		#for f in $flist; do
			#techo ${(q)f}
			#$cmd "$f"
			#confirm 'Compare' || continue
			#name=$(getfilename $f)
			#tmp=$TMPDIR/$name
			#gshow account_manager:$f > $tmp
			#meld $tmp "$f"
		#done
	else
		git diff "$@"
	fi
}
