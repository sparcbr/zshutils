VERSION=1.0.3
#lazyload=gclone,gpr,commit,github,gh,gpush,croot,gfollow,gunstage,gmerge,gchk
alias pull="git pull"
alias push="gpush"
alias gdiff="git diff --ignore-space-at-eol -b -w --ignore-blank-lines --minimal"
alias gadd="git add"
alias gadd-modified="git add \$(git diff --name-only --relative)"
alias gshow="git show --color=always"
alias gh='github'
alias unstage="gunstage"
alias git_get_tag='git describe --tags $(git rev-list --tags --max-count=1)'
alias glog2='git log --date=iso -g'

export github_token='b2e74253b94398066f3938bb63120f51ca7745ee'

[[ ! -v comp ]] && typeset -g -a comp

comp+=('gchk=git')
function gchk()
{
	git checkout "$@" && git status
}

comp+=('gunstage=git')
function gunstage()
{
	git restore --staged "$@"
}

function gfollow()
{
	local hash entries REPLY
	zparseopts -M -D - d=diff -diff=d
	#hashes=($(egrep '^commit' <(git log --follow "$@") | awk '{print $2}'))
	#entries=("${(@f)$(git log --format=format:%h\ %an\ \<%aE\>\ %ai\ %f --follow $1)}")
	while hash=$(
		chooser -f1 --ifs $'\n' --keys 'v f' \
			--head 'Commits containing "$1"' \
			--foot '(Enter) Show commit in terminal (v) Open commit in vim (f) view full file revision' \
			"$(git log --color=always --format=format:'%h %an <%aE> %ai %f' --follow $1)"
	)
	do
		opts=()
		case $REPLYKEY in
			'')
				gshow $hash $1
				;;
			v)
				gshow $hash $1 | gvim -
				;;
			f)
				gshow $hash:$1 | gvim -
				;;
			d)
				gvimdiff $1 <(gshow $hash:$1)
				;;
			m)
				meld $1 <(gshow $hash:$1)
				;;
		esac
	done
				#input -v -p <<-EOF
		#	<Esc>   q Exit
		#	        v vim
		#			/ search
		#	<Enter> or <Space> Go back to commit list
		#EOF
}

function gtag() #@TODO
{
	local tag hash
	echo TODO
	return 1
	hash=${2:-$(gselect -h)}
	tag=$()
	git tag -a $tag $hash
}

function gmerge() #@TODO
{
	local mergeHash branch status unmerged cmd=$1
	(($#)) && shift || cmd='status'
	mergeHash=$(git rev-parse MERGE_HEAD)
	if [[ -n $mergeHash ]]; then
		case $cmd in
			cancel|abort) git merge --abort
			;;
			finish|commit|continue) git commit
			;;
			status)
				local file
				techo -c warn "Merge in progress (${mergeHash:0:10})"
				unmerged=($(git ls-files --unmerged))
				#chooser -v file -f1 
				techo Needs merging: $unmerged
			;;
		esac
	else
		# case $cmd in
		# 	status)
		# 	;;
		# esac
		chooser -v branch -H 'Merge branch' -S "$1" -b2- --ifs $'\n' "$(git branch)" || cancel
		confirm "Merge branch $branch" && run git merge $branch --no-ff --no-commit
	fi
}

function ggrep() #@TODO
{
	local files pattern
	pattern=$(echo "$@" | awk -F' - ' '// {print $1}')
	files=$(echo "$@" | awk -F' - ' '// {print $2}')
	#pattern="${@%%_*}"
	#files="${@#*_}"
	#while arg in "$@"; do
	#    [[ "$arg" != "--" ]]
	#    [[ ]] && files+=" $arg"
	#done
	set -x
	git grep "$pattern" $(git rev-list --all -- ${=files}) -- ${=files}
	set +x
}

function commit() #@TODO
{
	local m args amend
	zparseopts -D -M - m:=m A=amend -amend=A
	[[ $amend[1] == '-A' ]] && amend='--amend'
	#@TODO check for empty changes
	if [[ -n "$1" && ${1:0:1} != - ]]; then
		m=(-m "$*")
	else
		args="$@"
	fi
	git commit $amend $m $args
}

function croot()
{
	git config --global --get alias.root > /dev/null || git config --global --add alias.root '!pwd'
	alias croot='cd $(git root)'
	cd $(git root)
}

# Added 2019-01-25 11:17:01
# https://github.com/search?q=
comp+=('github=cd' 'gh=cd')
function github()
{
	local url repo search echo
	zparseopts -D -M - r=repo s=search e=echo
	if [[ $# -eq 0 ]]; then
		[[ -d .git ]] && github . || open 'https://github.com/'
	elif [[ -n $search ]]; then
		open "https://github.com/search?q=$(omz_urlencode $*)"
	elif [[ -n $repo ]]; then
		url="https://github.com/$*"
		[[ -n $echo || ! -t 1 ]] && echo $url || open $url
	elif url=$(gitgetrepo "$*"); then
		if [[ -n $echo || ! -t 1 ]]; then
			echo $url
		elif [[ $url =~ '^git@github.com:(.*)/(.*)(.git)?$' ]]; then
			github -r $match[1]/$match[2]
		else
			open $url
		fi
	else
		githubAPI $echo "$@"
	fi
}

function githubAPI()
{
	local limit=20 endpoint='https://api.github.com/graphql' #request response fields
	local echo verbose ret args
	zparseopts -D -M - e=echo v=verbose

	args="${@%%.git}"

	request=$(cat) <<-GQL
	{ 
		"query":"query(\$search:String!,\$limit:Int!){
			search(query:\$search, first: \$limit, type: REPOSITORY){
				nodes {
				... on Repository {
					nameWithOwner, createdAt, updatedAt, stargazers { totalCount }, description
				}
				}
			}
		}",
		"variables":{ "search":"fork:true $args","limit":$limit }
	}
	GQL
	#	"variables":{ "search":"fork:true $(omz_urlencode "$*")","limit":$limit }
	fields='.data.search.nodes[] | .nameWithOwner,.createdAt[0:10],.updatedAt,.stargazers.totalCount,.description'
	request=${request//$'\n'/}
	response=$(curl -sS -H "Authorization: bearer $GITHUB_API_TOKEN" -X POST -d $request $endpoint)
	ret=$?
	type jq >/dev/null || chkCmd jq 
	(($#verbose)) && {
		jq -r <<<$request
		jq -r <<<$response
	}
	if ((ret == 0)); then
		local field
		typeset -a repos tmp
		while read -r field; do
			tmp+=("$(trim "$field")")
			if (($#tmp == 5)); then
				repos+=("$tmp")
				tmp=()
			fi
		done < <(jq -cr "$fields" <<<$response)

		if ((!$#repos)); then
			abort 10 'No repositories found'
		elif (($#repos == 1)); then
			github -r $echo $(explode "$repos" ' ' 1)
		else
			name=$(chooser -s' ' -f1 $repos "Open this search in github") || cancel
			if [[ $name == 'Open' ]]; then
				github -s "$*"
				abort 0
				return 
			else
				github -r $echo $name
			fi
		fi
	fi
}

function gitgetrepo()
{
	local repo d remote
	zparseopts -D -M - d:=d
	(
		d=${d[2]:-"$*"}
		[[ -n $d ]] || d='.'
		if [[ -n $d && -d $d ]]; then
			cd $d 2>/dev/null || {
				[ -t 1 ] && techo -c lred "Can't change to directory:$C_ $C[err]$d$C_"
				return 1
			}
		else
			[ -t 1 ] && techo -c lred "Directory not found:$C_ $C[err]$d$C_"
			return 1
		fi
		gremote || { [ -t 1 ] && techo -c warn 'No remotes'; return 10 }
		repo=$(git remote get-url $remote[1] 2>/dev/null) || {
			[ -t 1 ] && techo -c lred 'Git repository not found'
			return 1
		}
		[[ -n $repo ]] && echo $repo || {
			[ -t 1 ] && techo -c warn 'No remotes'
			return 10
		}
	)
}

function gselect()
{
	local var line lines noSelect nlimit='-500'
	integer i n
	setopt extendedglob
	lines=("${(@f)$(git log --graph --oneline --all $nlimit $@)}")

	# mark lines without content as non-selectable
	n=$#lines
	for ((i=1; i<=n; i++)); do
		if [[ ! $lines[$i] =~ [a-f0-9] ]]; then
			noSelect+=($i)
		fi
	done
	chooser -n $noSelect -R '([a-f0-9]{5,40} .*)' $lines
	#line=(${=line##[^a-f0-9]#})
}

function gpush()
{
	local remote branch
	if ! git push "$@"; then
		remote=(${1:-$VCS_STATUS_REMOTE_NAME})
		if [[ -z $remote ]]; then
			gremote || { techo -c warn 'No remotes'; return 10 }
		fi
		branch=${2:-$VCS_STATUS_LOCAL_BRANCH}
		if [[ -z $branch ]]; then
			getbranch || { techo -c warn 'No branch'; return 10 }
		fi
		git push --set-upstream $remote[1] $branch
	fi
}

function getbranch()
{
	typeset -g branch
	branch=$(git symbolic-ref --short ${1:-HEAD}) 
}

function gbranch() #@TODO
{
	local list diff cmd get current
	zparseopts -M -D - d=diff -diff=d l=list -list=l c=current

	cmd=($list $current)
	case $cmd in
		-c) getbranch "$@" ;;
		-l) listbranch "$@" ;;
		*) listbranch "$@" ;; 
	esac
}

function listbranch()
{
	local head merged opts=()
	zparseopts -M -D - --no-merged:=merged --merged:=merged

	(($#merged)) && opts+=($merged) || opts+=(--no-merged origin/master) 
	
	git --no-pager branch --sort=committerdate --format='%(HEAD) %(color:yellow)%(refname:short)%(color:reset) - %(color:red)%(objectname:short)%(color:reset) - %(contents:subject) - %(authorname) (%(color:green)%(committerdate:relative)%(color:reset))' --color=always $opts "$@"
}
function gremote()
{
	#local current
	#zparseopts c=current
	
	remote=($(git remote))
}

# Added 2019-09-03 19:04
function gclone()
{
	local repo dir

	include -r network
	repo=$1 ; dir=$2
	cd $HOME/repos

	{ [[ -n "$(urlinfo -s $repo)" ]] || repo="$(github -e $repo)" } || return

	while ((1)); do
		if [[ -z $dir ]]; then
			dir=${repo##*/}
			dir=${dir%%.git}
			if [[ -d $dir ]]; then
				local name=()
				urlinfo -v name -p $repo
				dir=${${name[1]#/*}/\//_}
			fi
			input -p $repo -t 'Clone into dir' -v dir $dir || return
		fi
		if git clone $repo $dir && [[ -d $dir ]] && cd $dir; then
			return 0
		fi
		techo -c lred Error cloning $repo
		confirm 'Try again' || return 1
	done
}

function gpr()
{
	local request owner 

	request=$(cat) <<-GQL
	{
	"query":query(owner:"$owner", name:"$repname") {
	  repository(owner:"$owner", name:"$repname") {
		pullRequests(states:[OPEN]) {
		  nodes {
			... on PullRequest {
			  id, author { login }, createdAt
			  merged, mergedAt, mergeable
			  body, changedFiles
			  commits(first: 100) {
				nodes { commit {
					oid
					message
					status { context(name: "x") { description } }
				  } }
			  }
			  comments(last: 100) {
				nodes { author { login }, updatedAt, minimizedReason }
			  }
			  labels(last: 100) {
				nodes {
				  ... on Label { color, name, description }
				}
			  }
			}
		  }
		}
	  },
	}
	"variables":{ "search":"fork:true $*","limit":$limit }
	}
	GQL
}

# Added 2019-12-04 18:50
function gbisect()
{
	cmd=$1
	case $bisectState in
		running)
			;;
		'')
			;;
	esac
}
