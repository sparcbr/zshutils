VERSION=1.0.5
setopt extendedglob

function findDev()
{
    local devin="$1"
    if [[ ! -b "$devin" ]]; then
        if [[ ! -f "$devin" ]]; then
            devin="/dev/$devin"
            [[ -b "$devin" ]] ||  { abort $? "Device not found: '$1'" ; return 1 }
        fi
    fi
    echo "$devin"
}

#@bug: shows partition as not mounted while it was really mounted
function lspart()
{
    sudo lsblk -o NAME,LABEL,SIZE,FSTYPE,MOUNTPOINT "$@" | awk "! /(SWAP)|(\/snap\/)|(system reserved)/"
    imgs=$(losetup --noheadings -l -O name,back-file)
    echo $imgs | grep -v '/snapd/' | sort
}

function sizeToKb()
{
	echo "$1" | sed 's/G/ * 1024 M/i;s/M/ * 1024 K/i;s/K//i' | bc
}

function sizeCompare()
{
	local s1 s2
	s1=$(sizeToKb $1) ;  s2=$(sizeToKb $2)
	[[ "$s1" -lt "$s2" ]] && echo -1 && return
	[[ "$s1" -gt "$s2" ]] && echo 1 && return
	echo 0
}

function deviceMount()
{
	[ -b "$1" ] || return 127
	if isDeviceMounted $1 && [[ "$(mntof $1)" == "$2" ]]; then
		return 0
	fi
	if [[ $# -ge 2 ]]; then
		isDir $2 || return 127
		! isDirMounted || return 2
		sudo mount $1 $2
	else
		udisksctl mount -b $1
	fi
}
#@TODO In the case of more than one mount of same device,
# all of them are unmounted
function dirUnmount()
{
	local err=0
	for dir; do
		if isDirMounted $dir; then
			deviceUnmount $(deviceof $dir) || ((err+=$?))
		fi
	done
	return $err
}

function deviceUnmount()
{
	local err=0 used var mnt
	zparseopts -D -M - u:=used -used:=u
	for dev; do
		if isDeviceMounted $dev; then
			var=$(udisksctl unmount -b $dev 2>&1)
			if [ $? -ne 0 ]; then
				((err+=1))
				if [[ "$var" = *busy* ]]; then
					mnt=$(mntof $dev)
					techo -c warn "Can't unmount. $dev is busy ($mnt)"
					sudo lsof $mnt | egrep -v '^(lsof|sudo|grep) '
				fi
			fi
		fi
	done
	return $err
}

function diskOff()
{
	udisksctl power-off -b $1
}
#@
function diskMount()
{
	local mnt dev parts line
	zparseopts -D -M - m:=mnt
	if [ -z "$mnt" ] || ! isDir $mnt; then
		mnt=/m
	fi
	dev=/dev/${1#/dev/}
	parts=("${(f)$(deviceInfo -t part --short $dev)}")
	#parts=(${dev}[0-9]##)
	for line in $parts; do
		eval $line
		deviceMount $dev $mnt/$label
	done
}

#@TODO SD wrapper util
# Status
# NODEVICE: no devices detected
# NOMEDIUM: no card detected
# NOPARTS: no partitions
# NOMOUNTS: no mounted partitions
# SOMEMOUNTS: not all partitions mounted
# ALLMOUNTS: all mounted
function SD()
{
	local status cmd
	status=SOMEMOUNTS
	case "$status" in
		(SOME|ALL)MOUNTS)
			;;
	esac
}
function mountSD()
{
	local dev mnt p
	echo TODO
	return
	zparseopts -D -M - m:=mnt
	[ -z "$mnt" ] && mnt=(-m /m/SD/)
	dev=${1:-$SDDEVICE}
	isSD $dev || SDDEVICE=$(findSD -d) || return
	diskMount $mnt $dev
}
function deviceInfo()
{
	local ret columns hotplug diskOnly args all short type data
	zparseopts -D -M - h=hotplug d=diskOnly a=all s=short -short=s t:=type -type:=t

	[ -n "$diskOnly" ] && type=disk

	columns='TYPE,NAME,SIZE,FSTYPE,LABEL,MOUNTPOINT'
	[ -z "$short" ] && columns+=',STATE,VENDOR,MODEL,SERIAL'
	[ -n "$hotplug" ] && columns+=',HOTPLUG'
	args=($hotplug $all $diskOnly --include 8 -o $columns --noheadings --pairs)
	data=$(sudo lsblk $args "$@")
	ret=$?
	[ -n "$hotplug" ] && data=$(egrep 'HOTPLUG="1"' <<<$data)
	[ -n "$type" ] && data=$(egrep '^TYPE="'$type'"' <<<$data)
	print -l $data
	return $?
}

function isSD()
{
	[ -n "$1" ] && [ -b "$1" ] && sudo fdisk -s "$1" >/dev/null 2>&1
}

function findSD()
{
	local var dev parts fparts disks found disk i cmd loop sdDev oldDev diskOnly 
	local TYPE NAME SIZE HOTPLUG FSTYPE LABEL MOUNTPOINT STATE VENDOR MODEL SERIAL

	zparseopts -D -M -- l=loop d=diskOnly o:=oldDev -cmd:=cmd

	typeset -a found
	while [ -z "$sdDev" ] || ! isSD "$sdDev"; do
		parts=("${(@f)$(deviceInfo -h -a $diskOnly)}") ; var=$?
		if [ $var -eq 0 ]; then
			disks=("${(@f)$(printf "%s\n" ${parts[@]} | egrep '^TYPE="disk"')}")
			var=$?
		fi

		if [ $var -ne 0 ]; then
			techo -c err 'No SD devices'
			[ -z "$loop" ] && return 1
			sleep 1
			continue
		fi
		if [ $var -eq 0 ] && [ -z "$diskOnly" ]; then
			parts=("${(@f)$(printf "%s\n" ${parts[@]} | egrep '^TYPE="part"')}")
		fi
		SDCARDSIZELIMIT='32G'
		i=1
		for line in $disks; do
			eval $line 
			if [ -z "$SIZE" ]; then
				techo -c warn "/dev/$NAME: $VENDOR $MODEL $SERIAL skipping: size 0: no media?"
			elif [[ $(sizeCompare "$SIZE" $SDCARDSIZELIMIT) -gt 0 ]]; then
				techo -c warn "/dev/$NAME: $VENDOR $MODEL $SERIAL skipping: size too big ($SIZE)"
				#@techo -c warn "if this is a mistake, setup a new size limit"
				#input -e '[[:digit:]][MG]' -p "Enter new size limit for SD cards" var
				#config set SDCARDSIZELIMIT $var
			else
				# prepend $i ? 
				found+=("/dev/$NAME size=$SIZE state=$STATE vendor=$VENDOR model=$MODEL serial=$SERIAL")
			fi
			((i++))
		done

		if [ $#found -gt 1 ]; then
			var=(${=$(chooser $found)})
		elif [ -n "$found" ]; then
			var=(${=found})
		else
			var=
		fi
		sdDev=$var[1]
		if [ -n "$sdDev" ]; then
			isSD $sdDev && break
		else
			techo -c err "No SD devices"
		fi

		[ -z "$loop" ] && return 1
		sleep 1
	done

	techo -c ok $var
	echo "$sdDev"
	dev=${sdDev#/dev/}
	[ -z "$diskOnly" ] && print -l "${parts[@]}" | egrep "NAME=\"${dev}[0-9]+\""
	return 0

		#if [[ "$CURRENTSDINFO" != "$var" ]]; then
		#	techo "Device changed: $dev"
		#	CURRENTSDINFO=($var)
		#fi

	#for i in $found; do
	#	disk=${disks[$i]}
	#	eval $disk
	#	echo $NAME size=$SIZE state=$STATE vendor=$VENDOR model=$MODEL serial=$SERIAL
	#	# udevadm info -n $NAME #| grep 'SD Reader'
	#	# ID_SERIAL=Generic_USB_SD_Reader_058F312D81B-0:0
	#	# ID_MODEL=USB_SD_Reader
	#	fparts=("${(@f)$(printf "%s\n" ${parts[@]} | egrep "NAME=\"${NAME}[0-9]+\"")}")
	#	for line in $fparts; do
	#		eval $line
	#		if [[ -n "$NAME" ]]; then
	#			techo $NAME size=$SIZE fstype=$FSTYPE label=$LABEL mount=$MOUNTPOINT
	#		fi
	#	done
	#done
}

# Added 2019-02-25 11:06:30
function mntof()
{
    awk -v needle=$1 '$1==needle {print $2}' /proc/mounts 2>/dev/null
}
function isDeviceMounted()
{
	[[ -n "$(mntof $1)" ]]
}

function deviceof()
{
	awk -v needle="$(fullpath "$1")" '$2==needle {print $1}' /proc/mounts 2>/dev/null
}
function isDirMounted()
{
	[[ -n "$(deviceof $1)" ]]
}
# take a mount dir, loop device or loop number
# $1: dir|[[/dev/]loop]N
# return: associated image file
function imageof()
{
	local name=$1 loopdev
	[ -z "$name" ] && return 1
	if isDir "$name"; then
		loopdev=$(deviceof "$name")
	elif [ "${name:0:1}" = '/' ]; then
		[ -b "$name" ] && loopdev=$name || return 1
	else
		loopdev=/dev/loop${name#loop}
		[ -b "$loopdev" ] || return 1
	fi
	[[ $loopdev = (/dev/(mapper/)#)#loop(#b)([0-9]##)p([0-9]##) ]] && loopdev=/dev/loop$match[1]
	losetup $loopdev -O BACK-FILE --noheadings
}

# Added 2019-03-01 15:48
function unloop()
{
    local loopNum devLoop devList
	zparseopts -D -E -M -- i:=img -img:=i
	if [[ -n "$img" ]]; then
		devLoop=$(losetup --all | grep $img[2] | cut -d':' -f1)
		[[ "$devLoop" =~ "loop([0-9]*)" ]] || return 1
		loopNum=$match[1]
	else
	    loopNum=$1
		devLoop=/dev/loop$loopNum
	fi
    devList=(${devLoop} /dev/mapper/loop${loopNum}p*(N) ${devLoop}p*(N))
    sudo umount $devList ; sudo kpartx -d $devLoop ; sudo losetup -d $devLoop || true
}

# Added 2019-02-26 14:17
function ptablecp()
{
    local tblbkp src dest
    src=$1
    dest=$2
    shift 2
    [[ -n $src && -n $dest ]] || { echo "need at least 2 arguments" ; return 1 }
    #tblbkp="$(getfilename $dest).bkup"
   # sudo sfdisk -d $dest | tee $dest.ptbl
    sudo sfdisk -d $src | sudo sfdisk $dest
}

# Added 2019-02-14 09:24
# Updated 2019-02-25 14:47
function sdd()
{
    local devin devout bs quiet status ioffset ooffset offset args dryrun
    zparseopts -M -D -K -E -A arr -- -dry=dryrun q=quiet -quiet=q -bs:=bs \
        -ioffset:=ioffset -ooffset:=ooffset -offset:=offset

    [[ $# -ge 2 ]] || return 1
    devin=$1
    devout=$2
    if [[ ${devin:0:2} == 'f:' ]]; then
        devin=${devin:2}
    else
        devin=$(findDev $devin)
    fi
    if [[ ${devout:0:2} == 'f:' ]]; then
        devout=${devout:2}
    else
        devout=$(findDev $devout)
    fi
	shift 2

    args=("$@")
    if [[ -n $offset ]]; then
        args+=("skip=$offset[2]")
        args+=("seek=$offset[2]")
    else
        [[ -n $ioffset ]] && args+=("skip=$ioffset[2]")
        [[ -n $ooffset ]] && args+=("seek=$ooffset[2]")
    fi

    echo "${C[b]}in=$devin => out=$devout$C_"
	#@TODO techo watch -n5 'killall -USR1 dd'
    ##oflag=dsync 
    if [[ -z $quiet ]]; then
        args+=('status=progress')
    fi
    args+=('conv=notrunc' 'conv=fdatasync')
	bs=${bs[2]:-512}
	run $quiet -s dd "if=$devin" "of=$devout" "bs=$bs" "${args[@]}"
    sync
}
