VERSION=1.0.5
setopt extendedglob

function findDev()
{
    local devin="$1"
    if [[ ! -b "$devin" ]]; then
        if [[ ! -f "$devin" ]]; then
            devin="/dev/$devin"
            [[ -b "$devin" ]] ||  { abort $? "Device not found: '$1'" ; return 1 }
        fi
    fi
    echo "$devin"
}

#@bug: shows partition as not mounted while it was really mounted
function lspart()
{
	awk "! /SWAP|(\/snap\/)|(system reserved)/" \
		<(sudo lsblk -o NAME,LABEL,SIZE,FSTYPE,MOUNTPOINT,SERIAL "$@")

	grep -v '/snapd/' <(losetup --noheadings -l -O name,back-file) | sort
}

function sizeToKb()
{
	echo "$1" | sed 's/G/ * 1024 M/i;s/M/ * 1024 K/i;s/K//i' | bc
}

function sizeCompare()
{
	local s1 s2
	s1=$(sizeToKb $1) ;  s2=$(sizeToKb $2)
	[[ "$s1" -lt "$s2" ]] && echo -1 && return
	[[ "$s1" -gt "$s2" ]] && echo 1 && return
	echo 0
}
function labelof()
{
	lsblk $1 -n -o FSTYPE
}
function deviceMount()
{
	local integer ret err=0
	local var dev devs mnt baseMnt
	zparseopts -D -M - M:=baseMnt
	[[ -n "$1" ]] || return 1
	[[ -n $baseMnt ]] && baseMnt=$baseMnt[2] || baseMnt=/m
	
	typeset -a devs
	for dev; do
		var=$(isDevice $dev)
		if [[ $? -eq 0 ]]; then
			devs+=($var)
		elif isDir $dev; then
			mnt=$var
		elif confirm "Create dir $var"; then
			run -S mkdir $var || return
			mnt=$var
		else
			cancel
		fi
	done

	if [[ $#devs -eq 1 ]] && [[ -n $mnt ]]; then
		dev=$devs[1]
		var=$(isDeviceMounted "$dev" "$mnt")
		ret=$?
		[[ $ret -eq 2 ]] && return 0
		if [[ $ret -eq 0 ]]; then
			techo -c red "$dev already mounted ($var)"
			confirm Remount on $mnt && deviceUnmount $dev || return 0
		fi
		var=$(isDirMounted $mnt $dev)
		ret=$?
		[[ $ret -eq 2 ]] && return 0
		[[ $ret -eq 0 ]] && {
			deviceUnmount $var || abortDevError MNTBUSY "$mnt ($var)"
		}
		run -s mount $dev $mnt
	else
		local parts line TYPE NAME SIZE FSTYPE LABEL MOUNTPOINT pids
		parts=("${(f)$(deviceInfo -t part --short $devs)}")
		typeset -a pids
		for line in $parts; do
			eval $line
			if [[ -n "$MOUNTPOINT" ]]; then
				techo -c warn "$NAME already mounted on $MOUNTPOINT"
				continue
			fi
			if [[ -z "$FSTYPE" ]]; then
				#@ no label, try to redetect, 
				# ask user to give a label
				techo -c red "$NAME: no file system detected"
				((err++))
				continue
			fi
			deviceMount $NAME "$baseMnt/$LABEL" &
			pids+=($!)
		done
		for var in $pids; do
			wait $var || ((err++))
		done

		[[ $err -eq 0 ]] && techo $OK || techo -c warn $err errors
		return err
	fi
}
#@TODO In the case of more than one mount of same device,
# all of them are unmounted
function dirUnmount()
{
	local err=0 dir dev
	for dir; do
		if [[ -d "$dir" ]]; then
			if dev=$(isDirMounted $dir); then
				deviceUnmount $dev || ((err++))
			fi
		else
			techo -c err "\"$dir\"$C_$C[red]: not a directory"
			((err++))
		fi
	done
	return $err
}

function deviceUnmount()
{
	local err=0 used var mnt dev
	local integer ret i
	zparseopts -D -M - u:=used -used:=u
	for dev; do
		dev=$(isDevice $dev) || {
			isDir $dev && dirUnmount $dev || { ((err++)); techo -c warn $dev is not a device; continue }
			continue
		}

			#@bug || { ((err++)); techo -c warn $dev is not a device; continue }
		mnt=$(isDeviceMounted $dev) || continue
		var=$(run -s -p "Unmounting $dev ($mnt)" udisksctl unmount -b $dev 2>&1) && continue
		var=$(run -s umount $dev)
		if [[ "$var" = *busy* ]]; then
			var=$(egrep -v '^(lsof|sudo|grep) ' <(sudo lsof $mnt))
			echo $var
			egrep '^adb ' <<< $var && {
				run adb kill-server
				isDeviceMounted $dev || continue
			}
			i=0
			while ! var=$(run -s umount $dev) && [[ $i -lt 4 ]]; do
				isDeviceMounted $dev || continue
				if [[ "$var" = *busy* ]]; then
					techo -c warn "$mnt is busy"
					var=$(egrep -v '^(lsof|sudo|grep) ' <(sudo lsof -f -- $mnt))
					echo $var
					egrep '^zsh ' <<< $var #@ show which shells are occupying $mnt
				fi
				((i++))
				sleep 1
			done
		fi
		isDeviceMounted $dev && ((err++))
	done
	return $err
}

function diskUnmount()
{
	local dev parts eject force
	zparseopts -D -M - e=eject f=force
	dev=$1
	parts=($(grep 'MOUNTPOINT=".\+"' <(deviceInfo -o NAME,MOUNTPOINT -t part $dev) | cut -f4 -d'"'))
	deviceUnmount $parts
	[[ -n $eject ]] && run -s eject $dev
}
function diskOff()
{
	sudo udisksctl power-off -b $1
}
NOBLKDEV=32
MNTBUSY=33
DEVERR[32]='not a block device'
DEVERR[33]='dir busy. Another device mounted here.'
function abortDevError()
{
	local cod=$1 ret
	ret=${(P)cod}
	abort $ret "ERR$cod: \"$2\" - ${DEVERR[$ret]}"
}

function diskMount()
{
	local mnt dev parts line devtmp err=0
	zparseopts -D -M - m:=mnt
	
	dev=${1:-$(chooser $(deviceInfo -d))}
	dev="/dev/${dev#/dev/}"
	[[ -b "$dev" ]] || abortDevError NOBLKDEV "$1"
	
	#@TODO: use disk uuid or disk identifier as default?
	[[ -n "$mnt" ]] && mnt="${mnt[2]}" || mnt="${2:-/m}"
	isDir "$mnt" || { confirm "Create dir $mnt" && run -S mkdir "$mnt" } || return $?

	deviceMount -M $mnt ${dev}[0-9]##
#	parts=("${(f)$(deviceInfo -t part --short $dev)}")
#	local TYPE NAME SIZE FSTYPE LABEL MOUNTPOINT
#	for line in $parts; do
#		eval $line
#		if [[ -n "$MOUNTPOINT" ]]; then
#			techo -c warn "$NAME already mounted on $MOUNTPOINT"
#			continue
#		fi
#		if [[ -z "$FSTYPE" ]]; then
#			#@ no label, try to redetect. How to be sure when "loading" is over? 
#			# How to be sure if loading is over and there is no label
#			# ask user to give a label
#			techo -c warn "$NAME: no file system detected"
#			((err++))
#			continue
#		fi
#		deviceMount $NAME "$mnt/$LABEL" || ((err++))
#	done
#	[[ $err -eq 0 ]] && techo $OK || techo -c warn $err errors
#	return err
}

#@TODO SD wrapper util
# Status
# NODEVICE: no devices detected
# NOMEDIUM: no card detected
# NOPARTS: no partitions
# NOMOUNTS: no mounted partitions
# SOMEMOUNTS: not all partitions mounted
# ALLMOUNTS: all mounted
function sd()
{
	local status cmd
	status=SOMEMOUNTS
	case "$status" in
		(SOME|ALL)MOUNTS)
			run -s umount
			;;
	esac
}
function mountSD()
{
	local dev mnt p
	zparseopts -D -M - m:=mnt
	dev=$(findSD -ld) || return
	diskMount $dev ${mnt[2]:-${2:-/m/SD}}
}
function deviceInfo()
{
	local ret columns hotplug diskOnly args all short type data
	zparseopts -D -M - h=hotplug d=diskOnly a=all s=short -short=s t:=type -type:=t o:=columns

	if [[ -n $columns ]]; then
		columns="TYPE,${columns[2]}"
	else
		columns='TYPE,NAME,SIZE,FSTYPE,LABEL,MOUNTPOINT'
		if [[ -z "$short" ]]; then
			columns+=',STATE,VENDOR,MODEL,SERIAL,HOTPLUG,RM'
		elif [[ -n "$hotplug" ]]; then
			columns+=',HOTPLUG,RM'
		fi
	fi

	args=($all $diskOnly --include 8 -o $columns --noheadings --pairs)
	data=$(sudo lsblk $args "$@")
	ret=$?
	[[ -n "$diskOnly" ]] && type=disk || type=$type[2]
	[[ -n "$hotplug" ]] && data=$(egrep 'HOTPLUG="1" RM="1"' <<<$data)
	[[ -n "$type" ]] && data=$(egrep '^TYPE="'$type'"' <<<$data)
	print -l $data
	return $ret
}

function isSD()
{
	[[ -n "$1" ]] && [[ -b "$1" ]] && sudo fdisk -s "$1" >/dev/null 2>&1
}

function findSD()
{
	local var parts disks disk sdDev found
	local integer i n=0 tries=1
	local TYPE NAME SIZE RM HOTPLUG FSTYPE LABEL MOUNTPOINT STATE VENDOR MODEL SERIAL
	local loop diskOnly oldDev cmd

	zparseopts -D -M -- l=loop d=diskOnly o:=oldDev -cmd:=cmd

	typeset -a found
	sdDev=$SDDEV
	[[ -n $loop ]] && tries=1000
	while ((n++ < tries))  && ! isSD $sdDev; do
		((n > 1)) && sleep 1
		parts=("${(@f)$(deviceInfo -h -a $diskOnly)}") ; var=$?
		if [ $var -eq 0 ]; then
			disks=("${(@f)$(printf "%s\n" ${parts[@]} | egrep '^TYPE="disk"')}")
			var=$?
		fi

		if [ $var -ne 0 ]; then
			SDDEV=
			techo -c err 'No SD devices'
			continue
		fi
		if [ $var -eq 0 ] && [ -z "$diskOnly" ]; then
			parts=("${(@f)$(printf "%s\n" ${parts[@]} | egrep '^TYPE="part"')}")
		fi
		SDCARDSIZELIMIT='32G'
		i=1
		found=()
		for line in $disks; do
			eval $line 
			if [[ -z "$SIZE" || -z "$SERIAL" ]]; then
				techo -c warn "/dev/$NAME: $VENDOR $MODEL skipping: " \
					"size=$SIZE, serial=$SERIAL : no media?"
			elif [[ $(sizeCompare "$SIZE" $SDCARDSIZELIMIT) -gt 0 ]]; then
				techo -c warn "/dev/$NAME: $VENDOR $MODEL $SERIAL skipping: too big ($SIZE)"
				#@techo -c warn "if this is a mistake, setup a new size limit"
				#input -e '[[:digit:]][MG]' -p "Enter new size limit for SD cards" var
				#config set SDCARDSIZELIMIT $var
			else
				# prepend $i ? 
				found+=("/dev/$NAME size=$SIZE state=$STATE vendor=$VENDOR model=$MODEL serial=$SERIAL")
			fi
			((i++))
		done

		#@TODO use a simple chooser 
		if [ $#found -gt 1 ]; then
			var=(${=$(chooser $found)})
		elif [ -n "$found" ]; then
			var=(${=found})
		else
			var=
			SDDEV=
			techo -c err 'No SD devices'
		fi
		sdDev=$var[1]
	done
	isSD $sdDev || { SDDEV= ; return 1 }
	techo -c ok SD=$sdDev
	SDDEV=$sdDev
	echo $sdDev
	var=${sdDev#/dev/}
	[ -z "$diskOnly" ] && print -l "${parts[@]}" | egrep "NAME=\"${var}[0-9]+\""
	return 0

		#if [[ "$CURRENTSDINFO" != "$var" ]]; then
		#	techo "Device changed: $dev"
		#	CURRENTSDINFO=($var)
		#fi

	#for i in $found; do
	#	disk=${disks[$i]}
	#	eval $disk
	#	echo $NAME size=$SIZE state=$STATE vendor=$VENDOR model=$MODEL serial=$SERIAL
	#	# udevadm info -n $NAME #| grep 'SD Reader'
	#	# ID_SERIAL=Generic_USB_SD_Reader_058F312D81B-0:0
	#	# ID_MODEL=USB_SD_Reader
	#	fparts=("${(@f)$(printf "%s\n" ${parts[@]} | egrep "NAME=\"${NAME}[0-9]+\"")}")
	#	for line in $fparts; do
	#		eval $line
	#		if [[ -n "$NAME" ]]; then
	#			techo $NAME size=$SIZE fstype=$FSTYPE label=$LABEL mount=$MOUNTPOINT
	#		fi
	#	done
	#done
}

# Added 2019-02-31 15:06:30
# and exists?
function isDevice()
{
	local loop dev=$1
	if [[ $dev = (#b)(/dev/(mapper/)#)#loop([0-9]##)(p[0-9]##)# ]]; then # isloop
		loop=$match[3]
		[[ -n $match[4] ]] && dev=/dev/mapper/loop$loop$match[4] || dev=/dev/loop$loop
		return 0
	fi
	if [[ -b $dev ]]; then # is device
		getfullpath $dev
		return
	fi
	if [[ ${dev:0:5} = /dev/ ]]; then # ghost device
		getfullpath $dev
		return
	fi
	if isDir $dev || [[ ${dev:0:1} = / ]]; then # not a device
		echo $dev
		return 1
	fi
	isDevice /dev/$dev # try again
}

# Added 2019-02-25 11:06:30
function mntof()
{
	local dev loop
	dev=$(isDevice $1)
	# [[ -b $dev ]] || return 1
    awk -v needle="$dev" '$1==needle {print $2}' /proc/mounts 2>/dev/null
}
function isDeviceMounted()
{
	local mnt="$(mntof $1)" 
	[[ -z "$mnt" ]] && return 1
	[[ -n "$2"  && "$mnt" = "$(getfullpath "$2")" ]] && return 2 # 0
	echo $mnt
	return 0
}

function deviceof()
{
	awk -v needle="$(getfullpath "$1")" '$2==needle {print $1}' /proc/mounts 2>/dev/null
}
function isDirMounted()
{
	local dev=$(deviceof "$1")
	[[ -z "$dev" ]] && return 1
	[[ "$dev" = "$2" ]] && return 2 #0
	echo $dev
	return 0
}
# take a mount dir, loop device or loop number
# $1: dir|[[/dev/]loop]N
# return: associated image file
function imageof()
{
	local name=$1 loopdev
	[[ -z $name ]] && return 1
	if isDir "$name"; then
		loopdev=$(deviceof "$name")
	elif [[ "${name:0:1}" = / ]]; then
		loopdev=$name
	else
		loopdev=/dev/loop${name#loop}
	fi
	[[ -b $loopdev ]] || abortDevError NOBLKDEV "$loopdev"
	[[ $loopdev = (/dev/(mapper/)#)#loop(#b)([0-9]##)p([0-9]##) ]] && loopdev=/dev/loop$match[1]
	losetup $loopdev -O BACK-FILE --noheadings
}

# Added 2019-03-01 15:48
function unloop()
{
    local loopNum devLoop devList
	zparseopts -D -E -M -- i:=img -img:=i
	if [[ -n "$img" ]]; then
		devLoop=$(losetup --all | grep $img[2] | cut -d':' -f1)
		[[ "$devLoop" =~ "loop([0-9]*)" ]] || return 1
		loopNum=$match[1]
	else
	    loopNum=$1
		devLoop=/dev/loop$loopNum
	fi
    devList=(${devLoop} /dev/mapper/loop${loopNum}p*(N) ${devLoop}p*(N))
    sudo umount $devList ; sudo kpartx -d $devLoop ; sudo losetup -d $devLoop || true
}

# Added 2019-02-26 14:17
function ptablecp()
{
    local tblbkp src dest
    src=$1
    dest=$2
    shift 2
    [[ -n $src && -n $dest ]] || { echo "need at least 2 arguments" ; return 1 }
    #tblbkp="$(getfilename $dest).bkup"
   # sudo sfdisk -d $dest | tee $dest.ptbl
    sudo sfdisk -d $src | sudo sfdisk $dest
}

# Added 2019-02-14 09:24
# Updated 2019-02-25 14:47
function sdd()
{
    local devin devout bs quiet status ioffset ooffset offset args dryrun
    zparseopts -M -D -K -E -A arr -- -dry=dryrun q=quiet -quiet=q -bs:=bs \
        -ioffset:=ioffset -ooffset:=ooffset -offset:=offset

    [[ $# -ge 2 ]] || return 1
    devin=$1
    devout=$2
    if [[ ${devin:0:2} == 'f:' ]]; then
        devin=${devin:2}
    else
        devin=$(findDev $devin)
    fi
    if [[ ${devout:0:2} == 'f:' ]]; then
        devout=${devout:2}
    else
        devout=$(findDev $devout)
    fi
	shift 2

    args=("$@")
    if [[ -n $offset ]]; then
        args+=("skip=$offset[2]")
        args+=("seek=$offset[2]")
    else
        [[ -n $ioffset ]] && args+=("skip=$ioffset[2]")
        [[ -n $ooffset ]] && args+=("seek=$ooffset[2]")
    fi

    echo "${C[b]}in=$devin => out=$devout$C_"
	#@TODO techo watch -n5 'killall -USR1 dd'
    ##oflag=dsync 
    if [[ -z $quiet ]]; then
        args+=('status=progress')
    fi
    args+=('conv=notrunc' 'conv=fdatasync')
	bs=${bs[2]:-512}
	run $quiet -s dd "if=$devin" "of=$devout" "bs=$bs" "${args[@]}"
    sync
}

# Added 2019-06-03 09:00
function ejectSD()
{
	isSD $SDDEV || findSD -d || return 0
	diskUnmount -e $SDDEV
}
