VERSION=1.0.5
setopt extendedglob

function findDev()
{
    local devin="$1"
    if [[ ! -b "$devin" ]]; then
        if [[ ! -f "$devin" ]]; then
            devin="/dev/$devin"
            [[ -b "$devin" ]] ||  { abort $? "Device not found: '$1'" ; return 1 }
        fi
    fi
    echo "$devin"
}

#@bug: shows partition as not mounted while it was really mounted
function lspart()
{
    sudo lsblk -o NAME,LABEL,SIZE,FSTYPE,MOUNTPOINT "$@" | awk "! /(SWAP)|(\/snap\/)|(system reserved)/"
    imgs=$(losetup --noheadings -l -O name,back-file)
    echo $imgs | grep -v '/snapd/' | sort
}

function sizeToKb()
{
	echo "$1" | sed 's/G/ * 1024 M/i;s/M/ * 1024 K/i;s/K//i' | bc
}

function sizeCompare()
{
	local s1 s2
	s1=$(sizeToKb $1) ;  s2=$(sizeToKb $2)
	[[ "$s1" -lt "$s2" ]] && echo -1 && return
	[[ "$s1" -gt "$s2" ]] && echo 1 && return
	echo 0
}

function deviceMount()
{
	local integer ret mnt
	local devtmp
	[[ -n "$1" ]] || return 1
	[[ -b "$1" ]] || abortDevError NOBLKDEV "$1"
	mnt=$(isDeviceMounted "$1" "$2")
	ret=$?
	[[ $ret -eq 2 ]] && return 0
	if [[ $ret -eq 0 ]]; then
		techo -c red "$1 already mounted ($mnt)"
		return 2
	fi

	if [ $# -ge 2 ]; then
		if isDir "$2"; then
			devtmp=$(isDirMounted "$2")
			ret=$?
			[[ $ret -eq 2 ]] && return 0
			[[ $ret -eq 0 ]] && {
				run -s umount $devtmp || abortDevError MNTBUSY "$2 ($devtmp)"
			}
		elif ! confirm "Create dir $2" || ! run -S mkdir "$2"; then
			return 127
		fi
		color sudo mount "$1" "$2"
	else
		udisksctl mount -b $1
	fi
}
#@TODO In the case of more than one mount of same device,
# all of them are unmounted
function dirUnmount()
{
	local err=0 dir
	for dir; do
		if [[ -d "$dir" ]]; then
			if isDirMounted "$dir"; then
				deviceUnmount $(deviceof "$dir") || ((err++))
			fi
		else
			techo -c err "\"$dir\"$C_$C[red]: not a directory"
			((err++))
		fi
	done
	return $err
}

function deviceUnmount()
{
	local err=0 used var mnt
	local integer ret
	zparseopts -D -M - u:=used -used:=u
	for dev; do
		mnt=$(isDeviceMounted $dev)
		ret=$?
		if [[ $ret -eq 0 ]]; then
			var=$(udisksctl unmount -b $dev 2>&1)
			if [[ $? -ne 0 ]]; then
				techo -c warn "Trying with sudo.."
				sudo umount $dev && continue
				((err+=1))
				if [[ "$var" = *busy* ]]; then
					mnt=$(mntof $dev)
					techo -c warn "Can't unmount. $dev is busy ($mnt)"
					sudo lsof $mnt | egrep -v '^(lsof|sudo|grep) '
				fi
			fi
		fi
	done
	return $err
}

function diskOff()
{
	udisksctl power-off -b $1
}
NOBLKDEV=32
MNTBUSY=33
DEVERR[32]='not a block device'
DEVERR[33]='dir busy. Another device mounted here.'
function abortDevError()
{
	local cod=$1 ret
	ret=${(P)cod}
	abort $ret "ERR$cod: \"$2\" - ${DEVERR[$ret]}"
}

function diskMount()
{
	local mnt dev parts line devtmp err=0
	zparseopts -D -M - m:=mnt
	
	dev=${1:-$(chooser $(deviceInfo -d))}
	dev="/dev/${dev#/dev/}"
	[[ -b "$dev" ]] || abortDevError NOBLKDEV "$1"
	
	#@TODO: use disk uuid or disk identifier as default?
	[[ -n "$mnt" ]] && mnt="${mnt[2]}" || mnt="${2:-/m}"
	isDir "$mnt" || { confirm "Create dir $mnt" && run -S mkdir "$mnt" } || return $?

	parts=("${(f)$(deviceInfo -t part --short $dev)}")
	for line in $parts; do
		eval $line
		if [[ -n "$MOUNTPOINT" ]]; then
			techo -c warn "$NAME already mounted on $MOUNTPOINT"
			continue
		fi
		if [[ -z "$FSTYPE" ]]; then
			#@ no label, try to redetect, 
			# ask user to give a label
			techo -c red "$NAME: no file system detected"
			((err++))
			continue
		fi
		deviceMount "/dev/$NAME" "$mnt/$LABEL" || ((err++))
	done
	[[ $err -eq 0 ]] && techo $OK || techo -c warn $err errors
	return err
}

#@TODO SD wrapper util
# Status
# NODEVICE: no devices detected
# NOMEDIUM: no card detected
# NOPARTS: no partitions
# NOMOUNTS: no mounted partitions
# SOMEMOUNTS: not all partitions mounted
# ALLMOUNTS: all mounted
function SD()
{
	local status cmd
	status=SOMEMOUNTS
	case "$status" in
		(SOME|ALL)MOUNTS)
			;;
	esac
}
function mountSD()
{
	local dev mnt p
	zparseopts -D -M - m:=mnt
	[ -n "$mnt" ] && mnt="${mnt[2]}" || mnt=${2:-/m/SD}
	dev=${1:-$SDDEVICE}
	isSD $dev || dev=$(findSD -d) || return 1
	SDDEVICE=$dev
	while ! diskMount $dev "$mnt"; do
		sleep 0.6
	done
}
function deviceInfo()
{
	local ret columns hotplug diskOnly args all short type data
	zparseopts -D -M - h=hotplug d=diskOnly a=all s=short -short=s t:=type -type:=t

	columns='TYPE,NAME,SIZE,FSTYPE,LABEL,MOUNTPOINT'
	[ -z "$short" ] && columns+=',STATE,VENDOR,MODEL,SERIAL'
	[ -n "$hotplug" ] && columns+=',HOTPLUG,RM'

	args=($all $diskOnly --include 8 -o $columns --noheadings --pairs)
	data=$(sudo lsblk $args "$@")
	ret=$?
	[ -n "$diskOnly" ] && type=disk || type=$type[2]
	[ -n "$hotplug" ] && data=$(egrep 'HOTPLUG="1" RM="1"' <<<$data)
	[ -n "$type" ] && data=$(egrep '^TYPE="'$type'"' <<<$data)
	print -l $data
	return $ret
}

function isSD()
{
	[[ -n "$1" ]] && [[ -b "$1" ]] && sudo fdisk -s "$1" >/dev/null 2>&1
}

function findSD()
{
	local var dev parts fparts disks found disk i cmd loop sdDev oldDev diskOnly 
	local TYPE NAME SIZE RM HOTPLUG FSTYPE LABEL MOUNTPOINT STATE VENDOR MODEL SERIAL

	zparseopts -D -M -- l=loop d=diskOnly o:=oldDev -cmd:=cmd

	typeset -a found
	while [ -z "$sdDev" ] || ! isSD "$sdDev"; do
		parts=("${(@f)$(deviceInfo -h -a $diskOnly)}") ; var=$?
		if [ $var -eq 0 ]; then
			disks=("${(@f)$(printf "%s\n" ${parts[@]} | egrep '^TYPE="disk"')}")
			var=$?
		fi

		if [ $var -ne 0 ]; then
			techo -c err 'No SD devices'
			[ -z "$loop" ] && return 1
			sleep 1
			continue
		fi
		if [ $var -eq 0 ] && [ -z "$diskOnly" ]; then
			parts=("${(@f)$(printf "%s\n" ${parts[@]} | egrep '^TYPE="part"')}")
		fi
		SDCARDSIZELIMIT='32G'
		i=1
		for line in $disks; do
			eval $line 
			if [[ -z "$SIZE" || -z "$SERIAL" ]]; then
				techo -c warn "/dev/$NAME: $VENDOR $MODEL $SERIAL skipping: \ 
					size=$SIZE, serial=$SERIAL : no media?"
			elif [[ $(sizeCompare "$SIZE" $SDCARDSIZELIMIT) -gt 0 ]]; then
				techo -c warn "/dev/$NAME: $VENDOR $MODEL $SERIAL skipping: size too big ($SIZE)"
				#@techo -c warn "if this is a mistake, setup a new size limit"
				#input -e '[[:digit:]][MG]' -p "Enter new size limit for SD cards" var
				#config set SDCARDSIZELIMIT $var
			else
				# prepend $i ? 
				found+=("/dev/$NAME size=$SIZE state=$STATE vendor=$VENDOR model=$MODEL serial=$SERIAL")
			fi
			((i++))
		done

		if [ $#found -gt 1 ]; then
			var=(${=$(chooser $found)})
		elif [ -n "$found" ]; then
			var=(${=found})
		else
			var=
		fi
		sdDev=$var[1]
		if [ -n "$sdDev" ]; then
			isSD $sdDev && break
		else
			techo -c err "No SD devices"
		fi

		[ -z "$loop" ] && return 1
		sleep 1
	done

	techo -c ok $var
	#@TODO	SDDEVICE=$sddev
	echo $sdDev
	dev=${sdDev#/dev/}
	[ -z "$diskOnly" ] && print -l "${parts[@]}" | egrep "NAME=\"${dev}[0-9]+\""
	return 0

		#if [[ "$CURRENTSDINFO" != "$var" ]]; then
		#	techo "Device changed: $dev"
		#	CURRENTSDINFO=($var)
		#fi

	#for i in $found; do
	#	disk=${disks[$i]}
	#	eval $disk
	#	echo $NAME size=$SIZE state=$STATE vendor=$VENDOR model=$MODEL serial=$SERIAL
	#	# udevadm info -n $NAME #| grep 'SD Reader'
	#	# ID_SERIAL=Generic_USB_SD_Reader_058F312D81B-0:0
	#	# ID_MODEL=USB_SD_Reader
	#	fparts=("${(@f)$(printf "%s\n" ${parts[@]} | egrep "NAME=\"${NAME}[0-9]+\"")}")
	#	for line in $fparts; do
	#		eval $line
	#		if [[ -n "$NAME" ]]; then
	#			techo $NAME size=$SIZE fstype=$FSTYPE label=$LABEL mount=$MOUNTPOINT
	#		fi
	#	done
	#done
}

# Added 2019-02-25 11:06:30
function mntof()
{
    awk -v needle="$(fullpath "$1")" '$1==needle {print $2}' /proc/mounts 2>/dev/null
}
function isDeviceMounted()
{
	local mnt="$(mntof $1)" 
	[[ -z "$mnt" ]] && return 1
	[[ -n "$2"  && "$mnt" = "$(fullpath "$2")" ]] && return 2 # 0
	echo $mnt
	return 0
}

function deviceof()
{
	awk -v needle="$(fullpath "$1")" '$2==needle {print $1}' /proc/mounts 2>/dev/null
}
function isDirMounted()
{
	local dev=$(deviceof "$1")
	[[ -z "$dev" ]] && return 1
	[[ "$dev" = "$2" ]] && return 2 #0
	echo $dev
	return 0
}
# take a mount dir, loop device or loop number
# $1: dir|[[/dev/]loop]N
# return: associated image file
function imageof()
{
	local name=$1 loopdev
	[ -z "$name" ] && return 1
	if isDir "$name"; then
		loopdev=$(deviceof "$name")
	elif [ "${name:0:1}" = '/' ]; then
		loopdev=$name
	else
		loopdev=/dev/loop${name#loop}
	fi
	[ -b "$loopdev" ] || { abortDevError NOBLKDEV "$loopdev" }
	[[ $loopdev = (/dev/(mapper/)#)#loop(#b)([0-9]##)p([0-9]##) ]] && loopdev=/dev/loop$match[1]
	losetup $loopdev -O BACK-FILE --noheadings
}

# Added 2019-03-01 15:48
function unloop()
{
    local loopNum devLoop devList
	zparseopts -D -E -M -- i:=img -img:=i
	if [[ -n "$img" ]]; then
		devLoop=$(losetup --all | grep $img[2] | cut -d':' -f1)
		[[ "$devLoop" =~ "loop([0-9]*)" ]] || return 1
		loopNum=$match[1]
	else
	    loopNum=$1
		devLoop=/dev/loop$loopNum
	fi
    devList=(${devLoop} /dev/mapper/loop${loopNum}p*(N) ${devLoop}p*(N))
    sudo umount $devList ; sudo kpartx -d $devLoop ; sudo losetup -d $devLoop || true
}

# Added 2019-02-26 14:17
function ptablecp()
{
    local tblbkp src dest
    src=$1
    dest=$2
    shift 2
    [[ -n $src && -n $dest ]] || { echo "need at least 2 arguments" ; return 1 }
    #tblbkp="$(getfilename $dest).bkup"
   # sudo sfdisk -d $dest | tee $dest.ptbl
    sudo sfdisk -d $src | sudo sfdisk $dest
}

# Added 2019-02-14 09:24
# Updated 2019-02-25 14:47
function sdd()
{
    local devin devout bs quiet status ioffset ooffset offset args dryrun
    zparseopts -M -D -K -E -A arr -- -dry=dryrun q=quiet -quiet=q -bs:=bs \
        -ioffset:=ioffset -ooffset:=ooffset -offset:=offset

    [[ $# -ge 2 ]] || return 1
    devin=$1
    devout=$2
    if [[ ${devin:0:2} == 'f:' ]]; then
        devin=${devin:2}
    else
        devin=$(findDev $devin)
    fi
    if [[ ${devout:0:2} == 'f:' ]]; then
        devout=${devout:2}
    else
        devout=$(findDev $devout)
    fi
	shift 2

    args=("$@")
    if [[ -n $offset ]]; then
        args+=("skip=$offset[2]")
        args+=("seek=$offset[2]")
    else
        [[ -n $ioffset ]] && args+=("skip=$ioffset[2]")
        [[ -n $ooffset ]] && args+=("seek=$ooffset[2]")
    fi

    echo "${C[b]}in=$devin => out=$devout$C_"
	#@TODO techo watch -n5 'killall -USR1 dd'
    ##oflag=dsync 
    if [[ -z $quiet ]]; then
        args+=('status=progress')
    fi
    args+=('conv=notrunc' 'conv=fdatasync')
	bs=${bs[2]:-512}
	run $quiet -s dd "if=$devin" "of=$devout" "bs=$bs" "${args[@]}"
    sync
}
