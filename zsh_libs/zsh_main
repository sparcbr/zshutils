VERSION=1.0.8
[[ -v comp ]] || typeset -g -a comp

function techo()
{
	local c args nonl print
	zparseopts -M -D - c:=c n=nonl P=print
	[[ -n "$nonl" ]] && args=('-n')
	[[ -z $TTY || ! -c $TTY ]] && TTY=/dev/null # stdout
	while [[ ${1[1]} = '-' ]]; do
		args+=("$1")
		shift
	done
	if [[ -n $c ]]; then
		local msg
		c=$c[2]
		if [[ $c = [0-9]## ]]; then
			msg="\e[38;5;${c}m$@$C_"
		else
			[[ -v C[$c] ]] && type colorSet >/dev/null && colorSet $c
			msg="${C[$c]}${@}$C_"
		fi
		if [[ -n $print ]]; then
			print -P $args $msg >$TTY
		else
			echo -e $args $msg >$TTY
		fi
	elif [[ -n "$print" ]]; then
		print -P $args "$@" >$TTY
	else
		echo -e $args "$@" >$TTY
	fi
}

function cancel() {
	local ret=$?
	((ret != 130)) && throw $ret
	abort 130 "$C[warn]Cancelled $@"
}

# @TODO skipErrors 
function abort()
{
	local skipErrors noexception verbose print
	integer cod=$1
	zparseopts -D - E=skipErrors e=noexception v:=verbose -P=print
	verbose=${verbose[2]:-2}
	(($#)) && shift
	((verbose>2 || DEBUG)) && fstack 1
	(($# && verbose)) && techo -c lred "$@"
	[[ -n $ABORT ]] && $ABORT $cod "$@" 

	#@TODO $ZSH_EVAL_CONTEXT =~ toplevel* , does not seem to work
	((EXIT)) && [[ ! -o interactive ]] && exit $cod

	[[ -z $noexception ]] && throw $cod
	return $cod
}

function implode()
{
	local _var _str _sep uniq _list ifs _Asep
	zparseopts -D -M - v:=_var u=uniq -ifs:=ifs A:=_Asep

	[[ -n $2 ]] && _sep=$2 || _sep=' '
	if [[ -n $_Asep ]]; then
		_Asep=$_Asep[2]
	else
		[[ $_sep != ':' ]] && _Asep=':' || _Asep=';'
	fi
	_list=()
	for key in ${(Pk)1}; do
		_list+=($key$_Asep${${(P)1}[$key]})
	done
	echo -n ${(@pj/$_sep/)_list}
}

function explode()
{
	local _var _str _sep uniq _list ifs _Asep
	zparseopts -D -M - v:=_var u=uniq -ifs:=ifs A:=_Asep
	_sep=${2:- }
	[ -t 0 ] && _str=$1 || read _str
	#[[ $_sep != ' ' ]] && _str=${_str// /$'\\ '}          #_str=${_str// /$'\\ '}
	_list=(${(@ps/$_sep/)_str})
	[[ -n $uniq ]] && _list=(${(@u)_list})
	[[ -n $_var[2] ]] && _var=$_var[2]
	if [[ -n $3 ]]; then
		[[ $3 == [0-9]## ]] || abort 1 "\$3=$3: not a number"
		if [[ -n $_var ]]; then
			typeset -g $_var
			#eval $_var="'${(Q)_str[$3]}'"
			eval $_var="'${_list[$3]}'"
			#echo ${(Q)_str[$3]}
		else
			print -r $_list[$3]
		fi
		#[ ! -t 1 ] && echo $_str[$3]
	else
		if [[ -n $_var ]]; then
			if [[ -n $_Asep ]]; then
				typeset -gA $_var
				_Asep=$_Asep[2]
				set -A $_var ${(@ps/$_Asep/)_list}
			else 
				typeset -ga $_var
				set -A $_var $_list
			fi
		else
			print -r $_list
		fi
		#[ ! -t 1 ] && echo $_list
	fi
}

function vartype() {
	print -rl -- ${(tP)1}
}

# Set info for a lib
function lib_set_info()
{
	local name info
	integer ll=$6 err
	if [[ $1 == '-E' ]]; then
		err=1
		shift
	fi
	name=${(U)1}
	typeset -Ag ZSH_${name}_INFO
	set -A ZSH_${name}_INFO ver $2 path "$3" required $4 mtime "$5" lazyload $ll err $err
}

function getmime()
{
	file -bi $(realpath "$@") | awk -F';' '{print $1}'
	((pipestatus[1])) && fstack
}

function zshLibReadHeader()
{
	local mime=$(getmime "$*") version header
	typeset -gA HEADER=()
	{ read version ; read header } < "$*" || return
	if [[ $mime = 'text/plain' && $version =~ VERSION=([0-9\.]+) ]]; then
		VERSION=$match[1]
		if [[ $header =~ ^\#(([[:alnum:]]+)(=([^[:blank:]]+))?)([[:blank:]]+([[:alnum:]]+)(=([^[:blank:]]+))?)*$ ]]
		then
			local opt val nop
			for nop opt nop val in $match; do
				case $opt in
					lazyload)
						;;
					*) techo -r opt $opt=$val; continue
						;;
				esac
				HEADER[$opt]=$val 
			done
		fi
	fi
}

function isZshLib()
{
	local mime=$(getmime "$*")
	[[ $mime = 'text/plain' && $(read -e <"$*") = VERSION=[0-9\.]## ]]
}

function isScript()
{
	local mime=$(getmime "$*")
	[[ $mime = 'text/x-shellscript' || $mime = 'text/plain' && $(read -e "$*") = VERSION=[0-9\.]## ]]
}

function typeOf()
{
	#[[ -o xtrace ]] && _dbg_fcfg $0
	local name ret tpath all result
	local integer i=2
	zparseopts -D -M - a=all p=p
	name=$1
	if [[ ! -f $name ]]; then
		ret=($(which -w $all $p $name))

		for ((i=2 ; $+ret[i] ; i+=2)); do
			type=$ret[i]

			if [[ $type == 'none' ]]; then
				echo 'none'
				return 1
			fi

			if [[ $type == 'command' ]]; then
				tpath=$(which -p $name)
				isScript $tpath && type='script'
			fi

			result+=($type:$tpath)
		done
		echo ${(z)${(@u)result//:/ }}
		return 0
	fi
	
	tpath=$name
	
	if isScript $tpath; then
		type='script'
	elif [[ -x $tpath ]]; then
		type='command'
	else
		echo 'none'
		return 1
	fi
	
	echo $type $tpath
	return 0
}

function zindent()
{
	local f
	[[ $# -gt 1 ]] && {
		f=1
		echo "function $1()\n{"
		shift
	}
	echo "$@" | sed -E 's/^([^{}])/\t\1/g'
	[[ -n $f ]] && echo "}"
}

function parseErrors()
{
	local line
	while read line; do
		#echo line=${(q)line}
		[[ $line == 'EOF' ]] && return
		if [[ $line =~ $'^(.+):([0-9]+): (parse error near) `(.*)\'' ]]; then
		elif [[ $line =~ $'^(.+):([0-9]+): (condition expected): "(.*)"' ]]; then
		elif [[ $line =~ $'^(.+):([0-9]+): (not an identifier):(.*)' ]]; then

		else
			techo -Pr "%F{9}${line}%f"
			continue
		fi
		
		print -Pr ${(@q)match}
	done
}

# Include a zsh lib
function include()
{
	local quiet verbose lpath lazyload required force
	local mtime info name
	zparseopts -D -M - l=lazyload p:=lpath -path:=lpath r=required -required=r \
		f=force q=quiet v:=verbose

	(( !$# )) && return 1
	verbose=${verbose[2]:-2}
	[[ -n $quiet ]] && verbose=0
	if [[ $1 = */* ]]; then
		lpath="$(getfullpath $1)"
		name="${$(getfilename $1)#zsh_*}"
	else
		name="${1#zsh_*}"
		if [[ -n $lpath ]]; then
			lpath=$lpath[2]
		else
			lpath="$ZSH_LIBS/zsh_$name"
		fi
	fi
		
	required=$#required

	if [[ ! -f $lpath ]]; then
		techo -P "[%1K%F{15}FAIL%f%k] %F{11}$lpath %F{9}not found%f"
		if ((required)); then
			techo -P "%F{9}Required %F{11}$name %F{9}not loaded%f"
			[[ ! -o interactive ]] && abort 127
		fi
		return 127
	fi

	mtime=$(stat -L --printf='%Y' $lpath) || techo -P "%F{9}stat error on %F{11}$lpath%f"
	info="ZSH_${(U)name}_INFO"

	if [[ -z ${(P)info} ||  # not loaded
		-n $force ||  # force load 
		${${(P)info}[mtime]} -lt $mtime ]] || # file was modified
		((${${(P)info}[lazyload]} && ! $#lazyload)) # was lazy loaded 
	then 
		if ! zshLibReadHeader $lpath; then
			techo -P "%F{11}$lpath %F{9}is not a zsh library%f"
			if ((required)); then
				[[ -o interactive ]] || abort 2
				return 2
			fi
			return 1
		fi

		if (($#lazyload)); then # @TODO
			local llfuncs func
			if [[ -n $HEADER[lazyload] ]]; then
				explode -v llfuncs ${HEADER[lazyload]} ','
				for func in $llfuncs; do
					functions[$func]="include $name && $func \$@"
				done
			fi
			lib_set_info $name $VERSION "$lpath" ${required:-0} "$mtime" 1
			return 0
		fi

		#[[ -o interactive ]] && 
		techo -P -r "Including %F{11}$name%f ("${lpath/$ZSH_LIBS/"\\$"ZSH_LIBS}") [%F{2}$VERSION%f]"
		if source $lpath; then
			lib_set_info $name $VERSION "$lpath" ${required:-0} "$mtime"
			#[[ -o interactive ]] &&
		else
			local error error2 file line tmp split
			lib_set_info -E $name $VERSION "$lpath" ${required:-0} "$mtime"
			techo -P "%F{11}$name%f [%K{1}%F{15}FAIL%f%k]"
			(
				#@TODO sort errors by file before opening files
				while read -pr tmp; do
					split=(${(z)tmp})
					file=$split[1]; line=$split[2]; error=$split[3]; error2=$split[4]
					techo -Pr "%F{3}$file:$line %F{9}${error} %K{1}%F{15}${error2}%f%k"
					if type v 2>&1 >/dev/null; then
						v $file:$line &
					else
						${EDITOR:-vim} $file +$line &
					fi
				done
				echo EOF >&p
			)

			if ((required)); then
				techo -P "\n%F{9}Required %F{11}\"zsh_$name\"%F{9} not loaded%f"
				[[ -o interactive ]] || abort 2
				return 2
			fi
			return $ret
		fi
	fi
}

function reload()
{
	local lib ll info libs=($(typeset -m 'ZSH_*_INFO' | cut -d'=' -f1))
	for lib in $libs; do
		if [[ $lib =~ 'ZSH_(.*)_INFO' ]]; then
			info=ZSH_${match[1]}_INFO
			((${${(P)info}[lazyload]})) && ll=-l || ll=''
			include -q $ll ${(L)match[1]}
		fi
	done
}

function TRAPHUP() { reload }
#function TRAPINT() {
#	kill -$1 $$
#	return $((128+$1))
#}

comp+=("inst=apt")
function inst()
{
	local machine cmd pkgs pkg
	zparseopts -D -M - m:=machine
	if [[ -z $machine ]]; then
		if (($#)); then
			cmd=("$@")
		else
			#@TODO findcmd(use inalias)
			cmd=(${$(fc -ln -1)[1]})
		fi
		for cmd in $cmd; do
			pkg=$(chooser -s':' -f1 --ifs $'\n' "$(dpkg -S '*/'$cmd)}") || return
			(($#pkg)) && sudo apt-get install $pkg
		done
	else
		echo "$@" >> $CFG/$machine[2].pkgs.txt
	fi
}

# Added 2019-09-05 00:57
# check if any item of array equals value
# in_array array_name value
function in_array()
{
	local name val _var
	zparseopts -D -M - v:=_var
	[[ -v $_var[2] ]] && _var=$_var[2]
	((${(P)#2[(re)$1]}))
}

#TODO call this within chooser
function match_array()
{
	local _var field choose sep
	zparseopts -D -M - v:=_var f:=field c=choose s:=sep
	[[ -v $_var[2] ]] || return 1
	_var=${_var[2]:-REPLY}
	typeset -ga $_var
	typeset "$_var=(${(M)${(P)2}:#${1}*})"
	[ -t 1 ] || echo $_var
	if (($#choose)); then
		chooser -v $_var $field $sep ${(P)_var} || cancel
	else
		(($#_var))
	fi
}

#@untested check escaping
function ltrim() {
	echo "${(q)*##[[:blank:]]##}"
}
function rtrim() {
	echo "${(q)*%%[[:blank:]]##}"
}
function trim()
{
	echo "$(rtrim "$(ltrim "$*")")"
}
#@TODO_in_array() { }

comp+=("aptinst=apt")
function aptinst()
{
	sudo apt-get install -y $@
}

# Added 2019-09-03 19:29
function libmonitor()
{
	# last   t       last+1.5   
	# | DIFF | SLEEP |
	local name evt pids
	float t lastt=0 diff
	while read -r evt name; do
		[[ $evt == 'exit' ]] && break
		pids=($(pidof inotifywait 2>/dev/null))
		if (($#pids > 1)); then
			command kill ${pids:0:-1}
		fi
		techo -c warn "$evt $name $$"
		t=$(date '+%s.%3N')
		((diff = t - lastt))
		if ((diff < 1.5)); then
			((diff = 1.5 - diff))
			sleep $diff
			((t += diff))
		fi
		((lastt = t))
		killall -HUP zsh
	done < <(inotifywait -m -q -e modify -r --format '%e %f' $ZSH_LIBS || echo "exit $?")
	return $name
}

# "include" itself
lib_set_info main $VERSION "$0" 1 "$(stat -L --printf='%Y' "$0")"

#if [[ -o interactive ]] && { [[ -z $LIBMON_PID ]] || ! kill -0 $LIBMON_PID 2>/dev/null }; then
if [[ -o interactive ]] && ! pidof inotifywait 2>&1 >/dev/null; then
	while ! type inotifywait 2>&1 >/dev/null; do
		aptinst inotify-tools || {
			ret=$?
			(( ret==130 || ret==1 )) && break
		}
	done && { libmonitor &! }
#	done && { libmonitor & export LIBMON_PID=$! }
fi

alias sudo='noglob do_sudo '
comp+=("do_sudo=sudo")
function do_sudo()
{
	integer glob=1
	local -a run
	include -r functions
	if [[ $# -gt 1 && $1 == -u ]]; then
		run=(command sudo -u $2)
		shift ; shift
	else
		run=(run -s)
	fi
	(($# == 0)) && 1=/bin/zsh
	while (($#)); do
		case $1 in
			command|exec|-) shift
				break
				;;
			nocorrect) shift
				;;
			noglob) glob=0; shift
				;;
			*) break
				;;
		esac
	done
	if ((glob)); then
		PATH="/sbin:/usr/sbin:/usr/local/sbin:$PATH" $run $~==*
	else
		PATH="/sbin:/usr/sbin:/usr/local/sbin:$PATH" $run $==*
	fi
}
