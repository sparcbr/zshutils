VERSION=1.0.2
#lazyload=urlfollow,urlinfo,vnc,imdb,globo

[[ ! -v comp ]] && typeset -g -a comp

function urlfollow() {
	curl -Ls -I -o /dev/null -w %{url_effective} $1
}

# Choose which parts of given url to return, or save in array (-v varname)
# Note, no decoding is done.
# All requested parts are returned in the order they appear in the url.
# TODO break query into key val parts or associative array
function urlinfo()
{
	local schemes=(ssh git https http ftp ftps file)
	local opts schemepat userpat hostpat pathpat querypat argpat out var
	userpat='[[:alnum:]]+'
	hostpat='[[:alnum:]][-.[:alnum:]]*\.[[:alpha:]]+'
	pathpat='~?[-_./[:alnum:]]+'
	argpat='[^&]+'
	querypat="$argpat(&$argpat)*"
	out=()
	zparseopts -D -M -A opts - v:=var 's' 'h' 'u' 'p' 'P' 'q' 'a' -all-schemes \
		-getscheme=s -getuser=u -getport=P -gethost=h -getpath=p -getquery=q \
		-setscheme: -setuser: -setport: -sethost: -setpath: -setquery:

	if (($+opts[--all-schemes])); then
		schemepat='[a-z]+'
	else
		schemepat=${(j.|.)schemes}
	fi

	# parts=($scheme'://' $user'@' $host ':'$port '/'$_path '?'$query)
	# ${(j..)parts}

	if [[ $1 =~ ($schemepat)'://'($~userpat'@')?($~hostpat)(':'[0-9]+)?('/'$~pathpat)?('\?'$~querypat)? ]]
	then
		(($+opts[-s])) && { scheme=($match[1]); out+=$scheme }
		(($+opts[-u])) && { user=(${match[2]%@}); out+=$user }
		(($+opts[-h])) && { host=($match[3]); out+=$host }
		(($+opts[-P])) && { port=(${match[4]#:}); out+=$port }
		(($+opts[-p])) && { _path=($match[5]); out+=$_path }
		(($+opts[-q])) && { query=(${match[6]#\?}); out+=$query }
	elif [[ $1 =~ (${~userpat}'@')?(${~hostpat}):($~pathpat)? ]]; then
		if (($+opts[-s])); then
			[[ $match[1] == 'git' ]] && scheme=(git) || scheme=(ssh)
			out=($scheme)
		fi
		(($+opts[-u])) && { user=(${match[1]%@}); out+=$user }
		(($+opts[-h])) && { host=($match[2]); out+=$host }
		(($+opts[-p])) && { _path=($match[3]); out+=$_path }
	else
		return 1
	fi
	[[ -v $var[2] ]] && set -A $var[2] "${(@)out}" || echo -n ${(q)out}
	return 0
}

function imdb()
{
	local e
	[[ $1 == '-e' ]] && { shift; e='-e' }

	url $e 'https://www.imdb.com/find?q=' "$*"
}

function url()
{
	local echo encode url arg c
	zparseopts -D -M -E - e=echo -no-color=c c:=c # E=encode -encode=E

	[[ -n $1 ]] || return 10
	url=$1
	arg=$2
	arg=$(omz_urlencode $arg)
	if [[ -n $c[2] ]]; then
		c=$C[$c[2]]
	elif [[ -z $c ]]; then
		c=$C[lgreen]
	else
		c=
	fi

	url=$url$arg
	if [[ -n $echo ]]; then
		echo $c$url
	else
		techo -c head 'Opening' $c$url
		open $url
	fi
}

function htmlget()
{
	local url output begin end tmp data opts code expr
	zparseopts -D -M - b:=begin e:=end o:=output u=update

	url=$1
	opts=(-q --show-errors 0 --show-warnings false --wrap 0)
	if (($#output)); then
		if [[ -z $update && -f $output[2] && "$(stat -c"%s" $output[2])" -gt 200000 ]]; then
			return 0
		fi
		opts+=($output)
	fi

	expr=()
	if (($#begin)); then
		expr+=(0 "/($begin[2].*)/" m
			'x=1; if (m[1]!="") print m[1]; next')
	else
		expr+=(BEGIN - -
			'x=1')
	fi

	if (($#end)); then
		expr+=(1 "/(.*)$end[2]/" m
			'print m[1]; x=2')
	fi
	expr+=(
		1 - -
			'print'
		- '/^¬/' -
			'print $2'
	)
	tmp=($(curl -Ss -w "\n¬ %{http_code}" -L $url | awkWrapper -e expr))
	code=$tmp[-1]
	if ((code!=200)); then
		techo -c err "curl: http code $code"
		return 1
	fi

	tidy $opts <<< $tmp[1,-2]
	return 0
}

# print: sed -n '/^<tr>/p' file
# ! delete: sed '/^<tr>/!d' file
function globo()
{
	local tmp vars expr data file=$HOME/globo.html
	zparseopts -D -M - u=update

	htmlget $update -b '<section class="schedule-item' \
		-e '<div class="grade-de-programacao-container-bottom"' \
		-o $file https://redeglobo.globo.com/sao-paulo/programacao || return

	vars=(today=$(date '+%Y%m%d') yesterday=$(date -d yesterday '+%Y%m%d') now=$(date '+%s'))
	expr=(
		BEGIN - -
			'pat_section="^<section .*data-event-container=\"("yesterday"|"today")[0-9]+\">"'
		0 'pat_section' m
			'x=1; dt=m[1]'
		1 '/<time .*data-start-time="([0-9]+)" data-end-time="([0-9]+)"/' m
			'dt1=m[1]; dt2=m[2]; if (now-dt2<10000  && dt1-now<10000) { ok=1; x=3; print "time",dt1,dt2,(dt1<now && now<dt2) } else if (ok) exit'
		3 '/^<h2><label[^>]*>([^<]*)</' m
			'print "title",m[1]'
		3 '/^<p>([^<]*)</' m
			'print "summary",m[1]'
		3 '/<dt>([^<]+)</' m
			'print "dt",m[1]'
		3 '/<dd>([^<]+)</' m
			'print "dd",m[1]'
		- '/<\/section>/' -
			'x=0'
	)

	if awkWrapper -v vars -e expr -o data $file; then
		local field isCurrent dt a c
		(($#data)) || abort 1 'No match'
		for tmp in $data; do
			a=($=tmp)
			field=$a[1]
			tmp=$a[2,-1]
			case $field in
				time)
					a=($=tmp)
					isCurrent=$a[3]
					((isCurrent)) && c=$C[warn] || c=
					techo -rc head $(date -d @$a[1] '+%d/%m/%Y:'$C_$c' %H:%M to '; date -d @$a[2] '+%H:%M')
					;;
				title)
					if ((isCurrent)); then
						techo -rc head "title: $C[ok]$tmp$C_"
					else
						techo -r "title: $tmp"
					fi
					;;
				summary)
					if ((isCurrent)); then
						techo -r "summary: $tmp"
					else
						techo -r "summary: $tmp[1,150] $C[lred]...$C_"
					fi
					;;
				dt)
					if ((isCurrent)); then
						dt=$tmp
					fi
					;;
				dd)
					if ((isCurrent)); then
						if [[ $dt == *Original* ]]; then
							techo -c lmagenta "$dt: $C[ok]$tmp $C[green]($(imdb -e $tmp))"
						else
							techo "$dt: $tmp"
						fi
					fi
					;;
			esac
		done
	fi
}

# Added 2019-04-04 14:54
function ipfind()
{
	local user=${1:-debian} net
	net=192.168.0
	for ip in $(seq $(($last+1)) 254); do
		last=$ip
		ping -W3 -c1 $net.$ip && ssh $user@$net.$ip
		echo ret=$?
	done
}

# Added 2020-01-15 19:12
function google()
{
	url 'https://www.google.com?q=' "$*"
}

# Added 2020-03-07 00:57
function vnc()
{
	local dir passfile
	#cfgget -v passfile -D "$HOME/.vnc/passwd" vncpassfile
	passfile="$HOME/.vnc/passwd"
	type x0vncserver || aptinst tigervnc-scraping-server
	while ! [[ -f $passfile ]]; do
		#input -p "Choose passfile" -v passfile || cancel
		#[[ $passfile != $default ]] && cfgset vncpassfile $passfile
		dir="$(getpath $passfile)"
		[[ -d $dir ]] || mkdir -p $dir
		vncpasswd $passfile
	done
	#DISPLAY=:0
	x0vncserver -display :0 -rfbport 5555 -rfbauth $passfile
}
