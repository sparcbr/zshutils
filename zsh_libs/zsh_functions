VERSION=1.0.7
#lazyload=run,input,chooser,confirm,todo 

#@TODO check i it's the top shell, and i it is, don't exit, just return: [[ $- =~ m ]] || EXIT=1
#		echo $ZSH_EVAL_CONTEXT
#		echo $SHLVL

autoload throw catch
setopt extendedglob pipefail nomultios 2>/dev/null
alias error="alert -e"
alias success="alert"

typeset -gA COLORS
COLORS=(
	 black 30  red 31  green 32  yellow 33  blue 34  magenta 35  cyan 36 lgray 37
	dkgray 90 lred 91 lgreen 92 lyellow 93 lblue 94 lmagenta 95 lcyan 96 white 97
	 bgblack  40  bgred  41  bggreen  42  bgyellow  43  bgblue  44  bgmagenta  45  bgcyan  46 bglgray  47
	bgdkgray 100 bglred 101 bglgreen 102 bglyellow 103 bglblue 104 bglmagenta 105 bglcyan 106 bgwhite 107
)

typeset -gA C
C=(
	head "\e[${COLORS[lblue]}m"
	err "\e[1;${COLORS[bgred]}m"
	red "\e[${COLORS[red]}m"
	lred "\e[${COLORS[lred]}m"
	ok "\e[${COLORS[lgreen]}m"
	warn "\e[${COLORS[lyellow]}m"
)
C_="\e[0m"

function colorSet()
{
	local c=$COLORS[${2:-$1}]
	[ -n "$c" ] && C[$1]="\e[${c}m" || return 1
}

CANCEL=" [${C[warn]}CANCEL$C_]"
FAIL=" [${C[err]}FAIL$C_]"
OK=" [${C[ok]}OK$C_]"

# like grep with optional 'cut -fN'
# regex pattern [Nfield]
function regex {
	gawk 'match($0,/'$1'/, ary) {print ary['${2:-'0'}']}'
}

function input()
{
	local _var p gui z c title raw _buttons okcodes
	local colors args str default
	zparseopts -M -D - c:=c p:=p v:=_var g=gui z=z t:=title r=raw \
		b:=_buttons -buttons:=b N:=okcodes -okcodes:=N D:=default

	typeset -A buttons=(Cancel 130 Ok 0)
	if (($#_buttons)); then
		explode -A':' -v _buttons $_buttons[2] ','
		buttons+=(${(kv)_buttons})
	fi

	colors=(-fg white -bg black)
	p=${p[2]:-Input text}
	title=${title[2]:-Input text}
	if [[ -n $_var[2] ]]; then
		_var=$_var[2]
		typeset -g $_var
		str=${@:-${(P)_var}}
	else
		str="$@"
	fi

	[[ ${p: -1} != ' ' ]] && techo -n -c ${c[2]:-head} "$p$C_: " || techo -n $c $p 

	if [[ -n $z ]] && type zenity>/dev/null; then
		str=$(zenity -title "$title" --entry --text="$p" --entry-text="$str") || cancel
		(($#str)) && techo -c warn -E $str
	elif type gxmessage >/dev/null && [[ -z $raw ]]; then
		{
			args=($colors -name name -center -ontop -wrap -buttons "$(implode -A':' buttons ',')")
			str=$(gxmessage $args -title "$title" -entrytext "$str" "$p")
			ret=$?
		} always {
			if catch '*'; then
				ret=$CAUGHT
			fi
			in_array $ret buttons || abort $ret
			if ((ret)) && ! in_array $ret okcodes; then
				((ret == 130)) && cancel
				return $ret
			fi
		}
		[[ -n $str ]] && techo -c warn -E $str
	else
		{
			if [[ -o zle ]]; then
				techo # newline, because vared clears the line
				vared -e str
			else
				read -r str
			fi
			ret=$?
		} always {
			if catch '*'; then
				ret=$CAUGHT
			fi
			in_array $ret buttons || abort $ret
			if ((ret)) && ! in_array $ret okcodes; then
				((ret == 130)) && cancel
				return $ret
			fi
		}
	fi
	
	(($#str)) || return 10
	
	if [[ -n $_var ]]; then
		typeset -g "$_var=$str"
	else
		echo $str
	fi
	return $ret
}

function confirm()
{
	local ret a c
	if [[ "$1" != -c ]]; then
		c=(-c lcyan)
	fi
	while read -t 0 -k -r a; do : ; done # clear buffer
	[[ -n $a ]] && echo
	techo -n $c "$@" "(y/N)? "
	if [[ -n "$BASH" ]]; then
		while [[ "$a" != 'y' ]] && [[ "$a" != 'n' ]]; do
			read -n 1 -r a
		done
		return $ret
	fi
	read -q -r "a"
	ret=$?
	echo
	return $ret
}

function chooser()
{
	local noSelect sep field bytes search default head foot
	local list ifs var chosen chosenList selectors events

	selectors=(${${(@uM)@#-[bfsR]}#-}) # keep options order

	zparseopts -D -M - c=color n:=noSelect R:=regex S:=search \
		 v:=var D:=default s:=sep f:=field -ifs:=ifs b:=bytes E:=events \
		 H:=head -head:=H p:=H F:=foot -foot:=F

	if (($#sep || $#field)); then
		(($#sep && $#field)) && unset 'selectors[(I)[sf]]'
		field=${field[2]:-1}
		sep=${sep[2]:- }
	fi

	(($#var)) && set -A list ${(P)var[2]}

	if [[ -n $ifs ]]; then
		explode -v list "$*" $ifs[2]
	else
		list+=("$@")
	fi

	if (($#list > 1)); then
		{
			[[ -n $default[2] ]] && default=($default[2])
			explode -v chosenList "$(
				NLIST_SET_SEARCH_TO=$search[2] \
				ZSHSELECT_START_IN_SEARCH_MODE=$+search[2] \
				ZSHSELECT_NONSELECTABLE=$noSelect[2] \
				ZSHSELECT_ENABLE_EVENTS=$events[2] \
				ZSHSELECT_HEAD=$head[2] ZSHSELECT_FOOT=$foot[2] \
				zsh-select $default "${(@)list:|default}" || throw $?
			)" $'\n'
		} always {
			if catch '*'; then
				return $CAUGHT
			fi
		}
	else
		chosenList=($list)
	fi

	(($#chosenList)) || return 10

	list=()
	for chosen in $chosenList; do
		local opt

		for opt in $selectors; do
			case $opt in
			R)
				if [[ $chosen =~ $regex[2] ]]; then
					chosen=$match
				else
					continue
				fi
			;;
			b)
				#chosen=$(echo - $chosen | cut $bytes)
				typeset -l "chosen=${chosen:bytes[1,]}"
			;;
			s|f)
				explode -v chosen $chosen $sep $field
			;;
			esac
		done
		list+=($chosen)
	done

	if (($#var)); then
		set -A "$var[2]" $list
	else
		print -r $list
	fi

	#[[ ! -t 1 || -z $var ]] && print -r $list
	return 0
}

#@TODO merge with inst() from zsh_main
function chkCmdInstall()
{
	if ! command -v $1 >/dev/null; then
		local deb cmd=$1 ret tmp
		techo -c lred "Command not found: ${C[head]}\"$cmd\"$C_ ${C[warn]}Searching for package to install."
		#@TODO make unique list of potential packages
		[[ -n $2 ]] && deb=$2 || {
			chooser -v deb -s':' -f1 --ifs=$'\n' "$(dpkg -S '*/'$1)" || return 127
		}
		techo "Installing $C[lcyan]$deb (provides $C[lcyan]$1)"
		sudo apt install $deb || {
			ret=$?
			techo -c err "Error installing $deb"
			return $ret
		}
	fi
}

function alert()
{
	local icon title body
	if [ "$1" = "-e" ]; then
		icon="error"
		title="Error"
		shift
		((!NOSND)) && sndplay error
	else
		icon="trophy-gold"
		title="Success"
		((!NOSND)) && sndplay success
	fi
	vflash
	notify-send --icon=$icon "$title" "$*"
}

function vflash()
{
	techo "\x1b[?5h" ; sleep .2 ; techo "\x1b[?5l"
}
function sndplay()
{
	local dir
	dir=$SOUNDS/$1
	[ -d "$dir" ] || { techo -c err "$dir doesn't exist" ; return }
	run -I libsox-fmt-mp3 - shuf -ezn 1 $dir/* | xargs -0 -n1 play
}

[ -z "$BASH" ] || return
function array_dump()
{
	local key val
	if [[ $(vartype "$1") = association* ]]; then
		techo -c head "dump of \"$1\" (size: ${(P)#1}):"
		for key in ${(Pk)1}; do
			techo "${(qq)key} -> ${(qqq)${(P)1}[$key]}"
		done
	elif [[ $(vartype "$1") = array* ]]; then
		techo -c head "dump of \"$1\" (size: ${(P)#1}):"
		for val in "${(qP@)1}"; do
			techo "${(qqq)val}"
		done
	else
		techo -c err "\"$1\": not an array."
	fi
}
function _push()
{
	local data l=${#stack[@]}
	typeset -A data
	data[name]=$1 ; data[verbose]=$2 # ; data[opts]=$3
	stack[$l]=$data
}
function _pop()
{
	local l=$(( ${#stack[@]} - 1 ))
	[ ${+stack[$l]} -eq 1 ] || { echo pop without push ; return 1 }
	data=$stack[$l]
	unset "stack[$l]"
}
function run_begin()
{
	local ret=$? verbose run
	zparseopts -M -D -A arr - v -verbose=v r: -run:=r
	for key in ${(k)arr}; do
		val=${arr[$key]}
		case $key in
			-v) verbose=1 ;;
			-r) runargs=$val ;;
		esac
	done
	name=$1
	_push $name $verbose
	if [ "$verbose" -eq 1 ]; then
		banner Starting: $name
	fi
}
function run_end()
{
	_pop
	if [ "${data[verbose]}" -eq 1 ]; then
		banner Finished: $data[name]
	fi
}

# Verbose levels
# 0: Quiet
# 1: Only errors
# 2: Show errors. Show header if given a string (-p something)
# 3: Errors and header
# 4: Above, plus finishing message
# 5: Above, plus associated command
# 6: Above, plus full command with arguments
comp+=('run=which')
function run()
{
	local ret cmd fullcmd logfile watch cmdPrefix
	local sudo trysudo dryrun verbose color alert print
	local cmdinst workdir skipErrors okcodes debug noEx

	if [[ ${1:0:1} == - ]]; then
		zparseopts -M -D - v:=verbose c:=color a=alert p:=print e=noEx A=noAbort \
			s=sudo S=trysudo n=dryrun I:=cmdinst -cd:=workdir E=skipErrors \
			l:=logfile w:=watch N:=okcodes -ok-exit-codes:=N D:=debug

		[[ $1 == - ]] && shift
		[[ ${1:0:1} == - ]] && { abort 2 "Invalid command: $1"; return }
	fi
	verbose=${verbose[2]:-6}

	cmd=$1
	if [[ -n $sudo ]]; then
		fullcmd=(sudo "$@")
		trysudo=
	else
		fullcmd=("$@")
	fi

	if [[ -z $color ]]; then
		color=(-c head)
	elif [[ $color[2] == (0|) ]] || ; then
		color=''
	fi
	[[ -n $print ]] && print=$print[2]
	if ((verbose>=3)) || [[ $verbose -ge 2 && -n $print ]] ; then
		if ((verbose>=6)); then
			[[ -n $print ]] && techo $color $print
			techo $color $fullcmd
		elif [[ -n $print ]]; then
			((verbose>=5)) && techo $color "$print ($cmd)" || techo $color $print
		else
			techo $color $cmd
		fi
	fi

	[[ -n $print ]] && print="$print : $cmd" || print=$cmd

	{
		[[ -n $dryrun ]] && return 0

		if [[ -n $workdir ]]; then
			workdir=$workdir[2]
			if [[ ! -d $workdir ]]; then
				confirm "$workdir does not exist. Create" && mkdir $workdir || throw $?
			fi
			cd $workdir || throw $?
		fi

		if [[ -z $okcodes ]]; then
			okcodes=(0)
		else
			explode -v okcodes $okcodes[2] ','
			in_array 0 okcodes || okcodes+=(0)  # add 0 to successful exit codes
		fi

		(($#debug)) && DEBUG=$debug[2]
		if ((DEBUG)); then
			(($#watch)) && _dbg_funcOnOff $watch[2]
			cmdPrefix='debug'
		elif (($#color)); then
			cmdPrefix='color'
		fi
		# # # # # # # # # #
		# Execute command #
		# # # # # # # # # #
		#waitPid -c "dirtyMem -P" color $fullcmd
		while ((1)); do
			if [[ -n $watch ]]; then
				$cmdPrefix $fullcmd & waitPid -c $watch[2] $!
			else
				$cmdPrefix $fullcmd
			fi
			ret=$?

			((ret==130)) && throw $ret
			if ((ret==127)); then
				chkCmdInstall $cmd $cmdinst[2] && continue || throw 127
			fi

			break
		done

		if ! in_array $ret okcodes; then
			if [[ -n $trysudo ]]; then
				techo "Trying with sudo"
				sudo $fullcmd
				ret=$?
			fi
			in_array $ret okcodes || throw $ret
		fi
	} always {
		if ((DEBUG)); then
			(($#watch)) && _dbg_funcOnOff $watch[2] 0
			#{ typeset +Ttf $cmd || set +x }
		fi
		if catch '*'; then
			local data=(${=CAUGHT})
			ret=$data[1]
			if ((ret==130)); then
				cancel $verbose "$print $CANCEL"
				return
			fi
			((verbose)) && techo "$print $FAIL ($data)"
			[[ -n $alert ]] && error "$print error: $data"
			abort $noAbort $noEx $skipErrors $ret
			return
		fi
	}

	if in_array $ret okcodes; then
		((verbose>=4)) && techo "$cmd $OK"
		[[ -n $alert ]] && success "$cmd finished successfully."
	else
		((verbose)) && techo "$print $FAIL"
		[[ -n $alert ]] && error "$print error: ret=$ret"
		abort $noAbort $noEx $skipErrors $ret
	fi
	return $ret
}

# nice fonts:
# smaller: pagga, future
# medium: smblock
function banner()
{
	local cmd c
	if type toilet >/dev/null; then
		cmd='toilet'
	elif type figlet>/dev/null; then
		cmd='figlet'
	else
		if type apt-get 2>&1 >/dev/null && aptinst toilet lolcat; then
			if type toilet >/dev/null; then
				cmd='toilet'
			fi
		elif type yum >&/dev/null; then
			sudo yum install figlet && cmd='figlet'
		fi
	fi
	if [ "$1" = '-c' ]; then
		c=$2 ; shift 2
	fi
	if [ -z "$cmd" ]; then
		if [ -n "$c" ]; then
			techo -c $c "$@"
		elif type lolcat >/dev/null; then
			echo "$@" | lolcat -F 0.3 -a -s 40 -d 4 >$TTY
		fi
		return
	fi
	
	if [ -n "$c" ]; then
		$cmd -f pagga "$@" | colorify -c $c >$TTY
	elif type lolcat >/dev/null; then
		$cmd -f pagga "$@" | lolcat -F 0.3 -a -s 40 -d 4 >$TTY
	else
		$cmd -f pagga "$@" >$TTY
	fi
}
function group()
{
	local line opt
	local integer i=0 num=${1:-1}
	zparseopts -D -M - g:=opt

	[[ -n $opt ]] && num=$opt[2]
	while IFS='' read -r line; do
		echo $line
		((++i % num == 0)) && echo ――――――――――――――――――――――――
	done
}
function color()
{
	{ "$@" 2>&1 1>&3 | sed $'s,.*,\e[91m&\e[0m,' 1>&2 } 3>&1
	return $pipestatus[1]
}

function colorify()
{
	local line data debug isPipe=0 highlight hcolor hl2 C1 Ch c
	zparseopts -D -M - D:=debug h:=highlight -hc:=hcolor c:=c
	#@broken: [ ! -p /dev/stdin ] && exit 0
	[ -t 0 ] || isPipe=1
	if [[ -n $highlight ]]; then
		highlight=$highlight[2]
		hcolor=${hcolor[2]:-head}
	fi
	if [[ -n $c ]]; then
		c=$c[2]
		if (($+C[$c])); then
			C1=$C[$c]
		else
			colorSet $c && C1=$C[$c] || C1=$C[lred]
		fi
		if (($+C[$hcolor])); then
			Ch=$C[$hcolor]
		else
			colorSet $hcolor && Ch=$C[$hcolor] || Ch=$C[head]
		fi
		[[ $C1 == $Ch ]] && Ch=$C[lred]
		hl2=$Ch$highlight$C1
		if ((isPipe)); then
			while IFS='' read -r line; do
				if [[ -n $highlight ]]; then
					echo "$C1${line//$highlight/$hl2}$C_"
				else
					echo "$C1$line$C_"
				fi
			done
		elif [[ -n $1 ]]; then
			data=("${(@f)@}")
			for line in $data; do
				if [[ -n $highlight ]]; then
					echo "$C1${line//$highlight/$hl2}$C_"
				else
					echo "$C1$line$C_"
				fi
			done
		fi
	else
		local a cmd
		if [[ -n $debug ]]; then
			cmd=$debug[2]
			# @TODO dbg_ps
			while IFS='' read line; do
				if [[ $line =~ ^\\+([0-9]?)\<?$cmd:([0-9]+)\>\ (.*) ]]; then
					techo -c lcyan $cmd:$match[2] $C_$match[3]
				elif [[ $line =~ ^\\+([0-9]?)\<?([[:alnum:]]+):([0-9]+)\>\ (.*) ]]; then
					((DEBUG)) && techo -c blue $match[1]:$match[2] $C_$match[3]
				else
					techo -c lred $line
				fi
			done
		else
			if [[ -n $highlight ]]; then
				if ((isPipe)); then
					grep --color $highlight'\|$'
				else
					grep --color $highlight'\|$' "$@"
				fi
			fi
		fi
#			debug=$(cat)<<-END
#				function dbg(c,name,line,str) {
#					printf("\033[%dm%s\033[1m%s\033[0m> %s\n",90+c,name,line,str)
#				}
#				/^\+${debug[2]}:([0-9]+)> (.*)/ {dbg(5,"${debug[2]}",\$1,\$2);next}
#				/^\+([[:alnum:]]+):([0-9]+)> (.*)\\n/ {dbg(6,\$1,\$2,\$3);next}
#			END
#		fi
#		a=$(cat)<<-END
#		BEGIN{IGNORECASE=1}
#		function color(c,s) {
#			printf("\033[%dm%s\033[0m\\n",90+c,s)
#		}
#		$debug
#		/\.php/ {color(2,\$0);next}
#		/error/ {color(1,\$0);next}
#		/success/ {color(2,\$0);next}
#		/warning/ {color(3,\$0);next}
#		/INFO/ {color(4,\$0);next}
#		/DBG/ {color(5,\$0);next}
#		{print}
#		END
#		echo "a=${(qqq)a}"
#		awk -D -f <(<<< ${(q)a}) </dev/stdin
	fi
}

# Added 2019-05-08 23:55
function refactor()
{
	local dir=${1:-.}
	#run -S find . -type f -name '*.php' -exec perl -pi -e "s/$search/$replace/g" {} +
	run -S grep < <(
		find $dir -type f -name '*.php' -print0 | xargs -0 sed "s/$search/${C[cyan]}${replace}${_C}/g"
	)
	confirm Replace || abort
	find $dir -type f -name '*.php' -print0 | xargs -0 sed -ised "s/$search/$replace/g"
}

alias q=todo
# Added 2019-06-04 17:47
function todo()
{
	local id filter cmd todo todos
	local box dir glob data baseDir=$CFG e='todo'
	zparseopts -D -M - d:=dir -dir:=d f:=filter
	if (( ! $# )); then
		cmd='show'
	else
		cmd=$1; shift
		data=$*
	fi
	if [[ $#dir[2] -ne 0 ]]; then
		dir=$dir[2]
	else
		dir=$baseDir
	fi
	[[ -d $dir ]] || abort 127 "\"$dir\": directory not found"
	[[ -z $filter ]] && filter='*'

	include file
	#glob=$dir/$filter.$e
	glob="$dir/*.$e"
	todos=($~glob(-N))
	case $cmd in
	add)
		todo=$(chooser -S $filter $todos:t "New todo" "Browse full path") || cancel
		if [[ "$todo" == "New todo" ]]; then
			todo=$(input -p "Enter todo id") || cancel
			[[ ${todo:0:1} != / ]] && todo=$dir/$todo
			[[ $(getext $todo) == $e ]] || todo=$todo.$e
		elif [[ "$todo" == "Browse full path" ]]; then
			todo=$(chooser --file -p "Choose path of todo") || cancel
			[[ ${todo:0:1} != / ]] && todo=$dir/$todo
			# @todo
			#dir=$(getfilename $todo)
		fi
		id=$(noext $(getfilename $todo) $e)
		input -p "Adding to todo $id" "$data" || cancel
		;;
	show)
		(($#todos)) || return 0
		todo=$(chooser -S $filter $todos:t) || cancel
		id=$(noext $(getfilename $todo) $e)
		run -p "Todo: $id" show $todo
		#for todo in $~glob(-N); do
		#	id=$(noext $(getfilename $todo) $e)
		#	run -p "Todo: $id" show $todo
		#done
		sqlite3 -batch test.db
		;;
	*)
		techo -c err "$cmd: invalid command"
		usage
	esac

	function usage() {
		local opts=(
			dir	 d "path(default: $baseDir)" 'base directory'
			help h ''						 'help'
		)
		techo "$0 [options] [add|show] [filter]"
		opts $opts
	}
}

function opts()
{
	local long opt desc arg 
	for long opt arg desc; do
		print -ca -C 4 -- --$long -$opt $arg $desc
	done
}

# Added 2019-09-20 15:55
function pizza()
{
	local integer mins=13
	local msg

	{ while (( mins )); do
		msg="$mins minutes left to pizza time"
		techo $msg
		sleep 60
		((mins--))
	done ; alert "pizza time" } &
}

# Added 2019-10-23 21:53
function kcmd()
{
	qdbus $KONSOLE_DBUS_SERVICE $KONSOLE_DBUS_SESSION "$@"
}
