VERSION=1.0.5

#@TODO check i it's the top shell, and i it is, don't exit, just return: [[ $- =~ m ]] || EXIT=1
#		echo $ZSH_EVAL_CONTEXT
#		echo $SHLVL

autoload throw catch
setopt extendedglob pipefail nomultios 2>/dev/null
alias error="alert -e"
alias success="alert"

typeset -gA COLORS
COLORS=(
	 black 30  red 31  green 32  yellow 33  blue 34  magenta 35  cyan 36 lgray 37
	dkgray 90 lred 91 lgreen 92 lyellow 93 lblue 94 lmagenta 95 lcyan 96 white 97
	 bgblack  40  bgred  41  bggreen  42  bgyellow  43  bgblue  44  bgmagenta  45  bgcyan  46 bglgray  47
	bgdkgray 100 bglred 101 bglgreen 102 bglyellow 103 bglblue 104 bglmagenta 105 bglcyan 106 bgwhite 107
)

typeset -gA C
C=(
	head "\e[${COLORS[lblue]}m"
	err "\e[1;${COLORS[bgred]}m"
	red "\e[${COLORS[red]}m"
	lred "\e[${COLORS[lred]}m"
	ok "\e[${COLORS[lgreen]}m"
	warn "\e[${COLORS[lyellow]}m"
)
C_="\e[0m"

function colorSet()
{
	local c=$COLORS[${2:-$1}]
	[ -n "$c" ] && C[$1]="\e[${c}m" || return 1
}

CANCEL=" [${C[warn]}CANCEL$C_]"
FAIL=" [${C[err]}FAIL$C_]"
OK=" [${C[ok]}OK$C_]"

function input()
{
	local var ret p gui z colors args tit
	zparseopts -M -D - p:=p s:=set g=gui z=z t:=tit
	colors=(-fg $C[head] -bg black)
	p=${p[2]:-Edit text}
	tit=${tit[2]:-Edit text}
	var=${(P)set[2]:-"$@"}
	techo -c head $p
	if [[ -n $z ]] && type zenity>/dev/null; then
		var=$(zenity -title "$title" --entry --text="$p" --entry-text="$var") || return
	elif type gxmessage >/dev/null; then
		args=($colors -center -ontop -wrap -buttons Cancel:1,Ok:0)
		var=$(gxmessage $args -title "$title" -entrytext "$var" "$p") || return
	else
		vared var || read -r var || return
	fi

	if [[ -n $set[2] ]]; then
		${(P)set[2]::=$var}
	else
		echo $var
	fi
	return 0
}

function confirm()
{
	local ret a c
	if [[ "$1" != -c ]]; then
		c=(-c lcyan)
	fi
	while read -t 0 -k -r a; do : ; done # clear buffer
	[[ -n $a ]] && echo
	techo -n $c "$@" "(y/N)? "
	if [[ -n "$BASH" ]]; then
		while [[ "$a" != 'y' ]] && [[ "$a" != 'n' ]]; do
			read -n 1 -r a
		done
		return $ret
	fi
	read -q -r "a"
	ret=$?
	echo
	return $ret
}

function chooser()
{
	local noSelect chosen ret sep
	zparseopts -M -D - c=color p:=print n:=noSelect R:=regex s:=sep

	#args=("${(@f)@}")
	if [ $# -gt 1 ]; then
		#if ! zmodload zsh/curses; then
		#	return 1
		#fi
		chosen="$(ZSHSELECT_NONSELECTABLE="$noSelect[2]" ZSHSELECT_START_IN_SEARCH_MODE=0 zsh-select "$@")"
	else
		chosen="$1"
	fi
	ret=$?
	[[ -z "$chosen" ]] && return 1
	if [[ -n $regex ]]; then
		if [[ $chosen =~ $regex[2] ]]; then
			echo "$match[@]"
			return 0
		fi
	elif [[ -n $sep ]]; then
		echo $(explode "$chosen" $sep)
		return 0
	else
		echo "$chosen"
		return 0
	fi
	return 1
}

function chkCmdInstall()
{
	local deb ret
		# techo -c err "$cmd command not found"
	if ! command -v $1 >/dev/null; then
		[ -n "$2" ] && deb=$2 || deb=$1
		techo "Installing $deb (provides $cmd)" 
		sudo apt install $deb
		ret=$?
		[ $ret -ne 0 ] && techo -c err "Error installing $deb"
		return $ret
	fi
}

function alert()
{
	local icon title body
	if [ "$1" = "-e" ]; then
		icon="error"
		title="Error"
		shift
		[ -z "$NOSND" ] && sndplay error || vflash 
	else
		icon="trophy-gold"
		title="Success"
		[ -z "$NOSND" ] && sndplay success || vflash 
	fi
	notify-send --icon=$icon "$title" "$*"
}

function vflash()
{
	techo "\x1b[?5h" ; sleep .2 ; techo "\x1b[?5l"
}
function sndplay()
{
	local dir
	dir=$SOUNDS/$1
	[ -d "$dir" ] || { techo -c err "$dir doesn't exist" ; return }
	run -I libsox-fmt-mp3 - shuf -ezn 1 $dir/* | xargs -0 -n1 play
}

# Say the file, line number and optional message for debugging
# Inspired by bash's `caller` builtin
# Thanks to https://unix.stackexchange.com/a/453153/143394
function yelp()
{
	# shellcheck disable=SC2154  # undeclared zsh variables in bash
	if [ -n "$BASH_VERSION" ]; then
		local file=${BASH_SOURCE[1]} func=${FUNCNAME[1]} line=${BASH_LINENO[0]}
	else  # zsh
		emulate -L zsh  # because we may be sourced by zsh `emulate bash -c`
		# $funcfiletrace has format:  file:line
		local file=${funcfiletrace[1]%:*} line=${funcfiletrace[1]##*:}
		local func=${funcstack[2]}
		[[ "$func" =~ '/' ]] && func=source  # $func may be filename. Use bash behaviour
	fi
	techo "${file##*/}:$func:$line $*"
}
[ -z "$BASH" ] || return
function array_dump()
{
	local key val
	if [[ $(vartype "$1") = association* ]]; then
		echo "dump of \"$1\":"
		for key val in ${(Pkv)1}; do
			echo "${(q)key} -> ${(q)val}"
		done
	elif [[ $(vartype "$1") = array* ]]; then
		echo "dump of \"$1\":"
		for key in ${(k)1}; do
			echo "${(qqqP)1[$key]}"
		done
	else
		echo "Not an array."
	fi
}
function _push()
{
	local data l=${#stack[@]}
	typeset -A data
	data[name]=$1 ; data[verbose]=$2 # ; data[opts]=$3
	stack[$l]=$data
}
function _pop()
{
	local l=$(( ${#stack[@]} - 1 ))
	[ ${+stack[$l]} -eq 1 ] || { echo pop without push ; return 1 }
	data=$stack[$l]
	unset "stack[$l]"
}
function run_begin()
{
	local ret=$? verbose run
	zparseopts -M -D -A arr - v -verbose=v r: -run:=r
	for key in ${(k)arr}; do
		val=${arr[$key]}
		case $key in
			-v) verbose=1 ;;
			-r) runargs=$val ;;
		esac
	done
	name=$1
	_push $name $verbose
	if [ "$verbose" -eq 1 ]; then
		banner Starting: $name
	fi
}
function run_end()
{
	_pop
	if [ "${data[verbose]}" -eq 1 ]; then
		banner Finished: $data[name]
	fi
}

# Verbose levels
# 0: Quiet
# 1: Only errors
# 2: Show errors. Show header if given a string (-p something)
# 3: Errors and header
# 4: Above, plus finishing message
# 5: Above, plus associated command
# 6: Above, plus full command with arguments
function run()
{
	local ret cmd fullcmd logfile watch
	local sudo trysudo dryrun verbose color alert print
	local cmdinst workdir skipErrors

	if [[ "${1:0:1}" == - ]]; then
		zparseopts -M -D - v:=verbose c:=color a=alert p:=print \
			s=sudo S=trysudo n=dryrun I:=cmdinst -cd:=workdir E=skipErrors \
			l:=logfile w:=watch

		[[ "$1" == - ]] && shift
		[[ ${1:0:1} == - ]] && { abort 1 "Invalid command: $1"; return }
	fi
	verbose=${verbose[2]:-6}

	cmd=$1
	if [[ -n "$sudo" ]]; then
		fullcmd=(sudo "$@")
		trysudo=
	else
		fullcmd=("$@")
	fi

	if [[ -z "$color" ]]; then
		color=(-c head)
	elif [[ "$color" = 'none' ]]; then
		color=''
	fi
	[[ -n $print ]] && print=$print[2]
	if [[ $verbose -ge 3 ]] || [[ $verbose -ge 2 && -n $print ]] ; then
		if [[ $verbose -ge 6 ]]; then
			[[ -n $print ]] && techo $color $print
			techo $color $fullcmd
		elif [[ -n $print ]]; then
			[[ $verbose -ge 5 ]] && techo $color "$print ($cmd)" || techo $color $print
		else
			techo $color $cmd
		fi
	fi
	[[ -n "$print" ]] && print="$print : $cmd" || print=$cmd
	{
		[[ -n $dryrun ]] && return 0

		if [[ -n $workdir ]]; then
			workdir=$workdir[2]
			if [[ ! -d $workdir ]]; then
				confirm "$workdir does not exist. Create" && mkdir "$workdir" || throw $?
			fi
			cd "$workdir" || throw $?
		fi

		# # # # # # # # # #
		# Execute command #
		# # # # # # # # # #
		if [[ -n "$color" ]]; then
			if [[ -n $watch ]]; then
				waitPid -c "dirtyMem -P" color $fullcmd
				color $fullcmd
			else
				color $fullcmd
			fi
		else
			if [[ -n $watch ]]; then
				waitPid -c "dirtyMem -P" $fullcmd
			else
				$fullcmd
			fi
		fi
		ret=$?

		[[ -n $DEBUG ]] && set -x
		[[ $ret -eq 130 ]] && throw $ret
		if [[ $ret -eq 127 ]]; then
			chkCmdInstall $cmd $cmdinst[2]
			ret=$?
			if [[ $ret -eq 0 ]]; then
				if [[ -n "$color" ]]; then
					color $fullcmd
				else
					$fullcmd
				fi
				ret=$?
			fi
		fi
		[[ -n $DEBUG ]] && { set +x ; return $ret }

		if [[ $ret -ne 0 ]]; then
			if [[ -n "$trysudo" ]]; then
				techo "Trying with sudo"
				color sudo $fullcmd
				ret=$?
			fi
			[[ $ret -ne 0 ]] && throw $ret
		fi
	} always {
		if catch '*'; then
			local data=(${=CAUGHT})
			ret=$data[1]
			if [[ $ret -eq 130 ]]; then
				cancel $verbose "$print $CANCEL"
				return
			fi
			[[ $verbose -ge 1 ]] && techo "$print $FAIL ($data)"
			[[ -n "$alert" ]] && error "$print error: $data"
			abort $skipErrors $ret
			return
		fi
	}

	case $ret in
	0)
		[[ $verbose -ge 4 ]] && techo "$cmd $OK"
		[[ -n "$alert" ]] && success "$cmd finished successfully."
	;;
	*)
		[[ $verbose -ge 1  ]] && techo "$print $FAIL"
		[[ -n "$alert" ]] && error "$print error: ret=$ret"
		abort $skipErrors $ret
	;;
	esac

	return $ret
}

# nice fonts:
# smaller: pagga, future
# medium: smblock
function banner()
{
	local cmd c
	if type toilet >/dev/null; then
		cmd='toilet'
	elif type figlet>/dev/null; then
		cmd='figlet'
	else
		if type apt-get 2>&1 >/dev/null && sudo apt install toilet lolcat; then
			if type toilet >/dev/null; then
				cmd='toilet'
			fi
		elif type yum >&/dev/null; then
			sudo yum install figlet && cmd='figlet'
		fi
	fi
	if [ "$1" = '-c' ]; then
		c=$2 ; shift 2
	fi
	if [ -z "$cmd" ]; then
		if [ -n "$c" ]; then
			techo -c $c "$@"
		elif type lolcat >/dev/null; then
			echo "$@" | lolcat -F 0.3 -a -s 40 -d 4 >$TTY
		fi
		return
	fi
	
	if [ -n "$c" ]; then
		$cmd -f pagga "$@" | colorify -c $c >$TTY
	elif type lolcat >/dev/null; then
		$cmd -f pagga "$@" | lolcat -F 0.3 -a -s 40 -d 4 >$TTY
	else
		$cmd -f pagga "$@" >$TTY
	fi
}
function group()
{
	local line opt
	local integer i=0 num=${1:-1}
	zparseopts -D -M - g:=opt

	[[ -n $opt ]] && num=$opt[2]
	while read -r line; do
		echo $line
		((++i % num == 0)) && echo ――――――――――――――――――――――――
	done
}
function color()
{
	{ "$@" 2>&1 1>&3 | sed $'s,.*,\e[91m&\e[0m,' 1>&2 } 3>&1
	return $pipestatus[1]
}

function colorify()
{
	#@broken: [ ! -p /dev/stdin ] && exit 0
	if [ "$1" = '-all' ] || [ "$1" = '-c' ]; then
		if [ "$1" = '-all' ]; then
			c='err'
		else
			c=$2
			shift
		fi
		shift
		while read line; do
			echo "${C[$c]}$line$C_"
		done
	else
		awk '
		BEGIN{IGNORECASE=1}
		function color(c,s) {
			printf("\033[%dm%s\033[0m\n",90+c,s)
		}
		/\.php/ {color(2,$0);next}
		/error/ {color(1,$0);next}
		/success/ {color(2,$0);next}
		/warning/ {color(3,$0);next}
		/INFO/ {color(4,$0);next}
		/DBG/ {color(5,$0);next}
		{print}
		' $1
	fi
}

# Added 2019-05-08 23:55
function refactor()
{
	local dir=${1:-.}
	#run -S find . -type f -name '*.php' -exec perl -pi -e "s/$search/$replace/g" {} +
	run -S grep < <(
		find $dir -type f -name '*.php' -print0 | xargs -0 sed "s/$search/${C[cyan]}${replace}${_C}/g"
	)
	confirm Replace || abort
	find $dir -type f -name '*.php' -print0 | xargs -0 sed -ised "s/$search/$replace/g"
}

alias q=queue
# Added 2019-06-04 17:47
function queue()
{
	local qid qidFilter place cmd queue
	zparseopts -D - p:=place
	if [[ $# -eq 0 ]]; then
		cmd=show
		qidFilter='*'
	else
		cmd=$1 ; shift
		if [[ -n $1 ]]; then
			qidFilter=$1
			shift
		fi
	fi
	place=${place[2]:-all}

	case $cmd in
	add)
		for queue in $CFG/queue.$place.$~qidFilter; do
			echo "$@" >> $queue
		done
	;;
	show|*)
		include file
		[[ $cmd != show && -z $qidFilter ]] && qidFilter=$cmd
		for queue in $CFG/queue.$place.$~qidFilter; do
			qid=$(getext $queue)
			run -p "Queue: $qid ($place)" more $queue 
		done
	;;
	esac

}

