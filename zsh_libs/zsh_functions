VERSION=1.0.5

#@TODO check i it's the top shell, and i it is, don't exit, just return: [[ $- =~ m ]] || EXIT=1
#		echo $ZSH_EVAL_CONTEXT
#		echo $SHLVL

autoload throw catch
setopt extendedglob pipefail nomultios 2>/dev/null
alias error="alert -e"
alias success="alert"

typeset -gA COLORS
COLORS=(
	 black 30  red 31  green 32  yellow 33  blue 34  magenta 35  cyan 36 lgray 37
	dkgray 90 lred 91 lgreen 92 lyellow 93 lblue 94 lmagenta 95 lcyan 96 white 97
	 bgblack  40  bgred  41  bggreen  42  bgyellow  43  bgblue  44  bgmagenta  45  bgcyan  46 bglgray  47
	bgdkgray 100 bglred 101 bglgreen 102 bglyellow 103 bglblue 104 bglmagenta 105 bglcyan 106 bgwhite 107
)

typeset -gA C
C=(
	head "\e[${COLORS[lblue]}m"
	err "\e[1;${COLORS[bgred]}m"
	red "\e[${COLORS[red]}m"
	lred "\e[${COLORS[lred]}m"
	ok "\e[${COLORS[lgreen]}m"
	warn "\e[${COLORS[lyellow]}m"
)
C_="\e[0m"

function colorSet()
{
	local c=$COLORS[${2:-$1}]
	[ -n "$c" ] && C[$1]="\e[${c}m" || return 1
}

CANCEL=" [${C[warn]}CANCEL$C_]"
FAIL=" [${C[err]}FAIL$C_]"
OK=" [${C[ok]}OK$C_]"

function input()
{
	local var str p gui z colors args title
	zparseopts -M -D - p:=p v:=var g=gui z=z t:=title
	colors=(-fg white -bg black)
	p=${p[2]:-Input text}
	title=${title[2]:-Input text}
	if [[ -n "${var[2]}" ]]; then
		var="${var[2]}"
		[[ -v $var ]] || typeset -g $var
	fi
	str=${@:-${(P)var}}
	techo -n -c head "$p: "
	if [[ -n $z ]] && type zenity>/dev/null; then
		str=$(zenity -title "$title" --entry --text="$p" --entry-text="$str") || cancel
		techo -c warn $str
	elif type gxmessage >/dev/null; then
		args=($colors -center -ontop -wrap -buttons Cancel:1,Ok:0)
		str=$(gxmessage $args -title "$title" -entrytext "$str" "$p") || cancel
		techo -c warn $str
	else
		vared str || read -r str || cancel
	fi

	if [[ -n $var ]]; then
		${(P)var::=$str}
	else
		echo $str
	fi
	return 0
}

function confirm()
{
	local ret a c
	if [[ "$1" != -c ]]; then
		c=(-c lcyan)
	fi
	while read -t 0 -k -r a; do : ; done # clear buffer
	[[ -n $a ]] && echo
	techo -n $c "$@" "(y/N)? "
	if [[ -n "$BASH" ]]; then
		while [[ "$a" != 'y' ]] && [[ "$a" != 'n' ]]; do
			read -n 1 -r a
		done
		return $ret
	fi
	read -q -r "a"
	ret=$?
	echo
	return $ret
}

# Receive a list and the default selected item.
# Put the default item on the first position.
# @param string selected
# @param string[] list
function mklist()
{
	local list first i
	first=$1
	list=($1)
	shift
	for i; do [[ "$i" != "$first" ]] && list+=($i) ; done
	echo "${list[@]}"
}

function chooser()
{
	local noSelect chosen ret sep field search default
	zparseopts -M -D - c=color p:=print n:=noSelect R:=regex s:=sep f:=field \
		S:=search D:=default

	if [ $# -gt 1 ]; then
		local args
		chosen=$(
			NLIST_SET_SEARCH_TO=$search[2] \
			ZSHSELECT_START_IN_SEARCH_MODE=$+search \
			ZSHSELECT_NONSELECTABLE=$noSelect[2] \
			zsh-select $default $@
		)
		#(($#search[2])) && args+=(NLIST_SET_SEARCH_TO=$search[2])
		#(($#noSelect[2])) && args+=(ZSHSELECT_NONSELECTABLE=$noSelect[2])
		#(($#search[2])) && args+=(NLIST_SET_SEARCH_TO=$search[2])
		#chosen=$($args ZSHSELECT_START_IN_SEARCH_MODE=$+search zsh-select $@)
		ret=$?
	else
		chosen="$1"
	fi
	[[ $#chosen -gt 0 ]] || return $ret
	if [[ -n $regex ]]; then
		if [[ $chosen =~ $regex[2] ]]; then
			echo "$match[@]"
			return 0
		fi
	elif [[ -n $sep ]]; then
		echo $(explode "$chosen" $sep[2] $field[2])
		return 0
	else
		echo "$chosen"
		return 0
	fi
	return 1
}

function chkCmdInstall()
{
	local deb ret
		# techo -c err "$cmd command not found"
	if ! command -v $1 >/dev/null; then
		[ -n "$2" ] && deb=$2 || deb=$1
		techo "Installing $deb (provides $cmd)"
		sudo apt install $deb
		ret=$?
		[ $ret -ne 0 ] && techo -c err "Error installing $deb"
		return $ret
	fi
}

function alert()
{
	local icon title body
	if [ "$1" = "-e" ]; then
		icon="error"
		title="Error"
		shift
		[ -z "$NOSND" ] && sndplay error || vflash
	else
		icon="trophy-gold"
		title="Success"
		[ -z "$NOSND" ] && sndplay success || vflash
	fi
	notify-send --icon=$icon "$title" "$*"
}

function vflash()
{
	techo "\x1b[?5h" ; sleep .2 ; techo "\x1b[?5l"
}
function sndplay()
{
	local dir
	dir=$SOUNDS/$1
	[ -d "$dir" ] || { techo -c err "$dir doesn't exist" ; return }
	run -I libsox-fmt-mp3 - shuf -ezn 1 $dir/* | xargs -0 -n1 play
}

# Say the file, line number and optional message for debugging
# Inspired by bash's `caller` builtin
# Thanks to https://unix.stackexchange.com/a/453153/143394
function yelp()
{
	# shellcheck disable=SC2154  # undeclared zsh variables in bash
	if [ -n "$BASH_VERSION" ]; then
		local file=${BASH_SOURCE[1]} func=${FUNCNAME[1]} line=${BASH_LINENO[0]}
	else  # zsh
		emulate -L zsh  # because we may be sourced by zsh `emulate bash -c`
		# $funcfiletrace has format:  file:line
		#local file=${funcfiletrace[1]%:*} line=${funcfiletrace[1]##*:}
		#local func=${funcstack[2]}
		#[[ "$func" =~ '/' ]] && func=source  # $func may be filename. Use bash behaviour
		# techo "${file##*/}:$func:$line $*"
		#print -l -- funcfiletrace $funcfiletrace - funcsourcetrace $funcsourcetrace - funcstack $funcstack - functrace $functrace
		local integer n=$#functrace i=${1:-0}
		[[ $functrace[$n] = $SHELL:* ]] && ((n--))
		for ((i++; i<=n; i++)); do
			techo -c warn $functrace[$i] $_C in $C[lgray]$funcfiletrace[$i]
		done
	fi
}
[ -z "$BASH" ] || return
function array_dump()
{
	local key val
	if [[ $(vartype "$1") = association* ]]; then
		techo -c head "dump of \"$1\" (size: ${(P)#1}):"
		for key in ${(Pk)1}; do
			techo "${(qq)key} -> ${(qqq)${(P)1}[$key]}"
		done
	elif [[ $(vartype "$1") = array* ]]; then
		techo -c head "dump of \"$1\" (size: ${(P)#1}):"
		for val in "${(P@)1}"; do
			techo "${(qqq)val}"
		done
	else
		techo -c err "\"$1\": not an array."
	fi
}
function _push()
{
	local data l=${#stack[@]}
	typeset -A data
	data[name]=$1 ; data[verbose]=$2 # ; data[opts]=$3
	stack[$l]=$data
}
function _pop()
{
	local l=$(( ${#stack[@]} - 1 ))
	[ ${+stack[$l]} -eq 1 ] || { echo pop without push ; return 1 }
	data=$stack[$l]
	unset "stack[$l]"
}
function run_begin()
{
	local ret=$? verbose run
	zparseopts -M -D -A arr - v -verbose=v r: -run:=r
	for key in ${(k)arr}; do
		val=${arr[$key]}
		case $key in
			-v) verbose=1 ;;
			-r) runargs=$val ;;
		esac
	done
	name=$1
	_push $name $verbose
	if [ "$verbose" -eq 1 ]; then
		banner Starting: $name
	fi
}
function run_end()
{
	_pop
	if [ "${data[verbose]}" -eq 1 ]; then
		banner Finished: $data[name]
	fi
}

# Verbose levels
# 0: Quiet
# 1: Only errors
# 2: Show errors. Show header if given a string (-p something)
# 3: Errors and header
# 4: Above, plus finishing message
# 5: Above, plus associated command
# 6: Above, plus full command with arguments
function run()
{
	local ret cmd fullcmd logfile watch
	local sudo trysudo dryrun verbose color alert print
	local cmdinst workdir skipErrors okcodes

	if [[ "${1:0:1}" == - ]]; then
		zparseopts -M -D - v:=verbose c:=color a=alert p:=print \
			s=sudo S=trysudo n=dryrun I:=cmdinst -cd:=workdir E=skipErrors \
			l:=logfile w:=watch N:=okcodes -ok-exit-codes:=N

		[[ "$1" == - ]] && shift
		[[ ${1:0:1} == - ]] && { abort 1 "Invalid command: $1"; return }
	fi
	verbose=${verbose[2]:-6}

	cmd=$1
	if [[ -n "$sudo" ]]; then
		fullcmd=(sudo "$@")
		trysudo=
	else
		fullcmd=("$@")
	fi

	if [[ -z "$color" ]]; then
		color=(-c head)
	elif [[ "$color" = 'none' ]]; then
		color=''
	fi
	[[ -n $print ]] && print=$print[2]
	if [[ $verbose -ge 3 ]] || [[ $verbose -ge 2 && -n $print ]] ; then
		if [[ $verbose -ge 6 ]]; then
			[[ -n $print ]] && techo $color $print
			techo $color $fullcmd
		elif [[ -n $print ]]; then
			[[ $verbose -ge 5 ]] && techo $color "$print ($cmd)" || techo $color $print
		else
			techo $color $cmd
		fi
	fi
	[[ -n "$print" ]] && print="$print : $cmd" || print=$cmd
	{
		[[ -n $dryrun ]] && return 0

		if [[ -n $workdir ]]; then
			workdir=$workdir[2]
			if [[ ! -d $workdir ]]; then
				confirm "$workdir does not exist. Create" && mkdir "$workdir" || throw $?
			fi
			cd "$workdir" || throw $?
		fi
		if [[ -z $okcodes ]]; then
			okcodes=(0)
		else
			explode -v okcodes "$okcodes[2]" ','
			in_array okcodes 0 || okcodes+=(0)  # add 0 to successful exit codes
		fi

		# # # # # # # # # #
		# Execute command #
		# # # # # # # # # #
		if [[ -n "$color" ]]; then
			if [[ -n $watch ]]; then
				waitPid -c "dirtyMem -P" color $fullcmd
				color $fullcmd
			else
				color $fullcmd
			fi
		else
			if [[ -n $watch ]]; then
				waitPid -c "dirtyMem -P" $fullcmd
			else
				$fullcmd
			fi
		fi
		ret=$?

		if [[ -n $DEBUG ]]; then
			typeset -tf $cmd || set -x
		fi
		[[ $ret -eq 130 ]] && throw $ret
		if [[ $ret -eq 127 ]]; then
			chkCmdInstall $cmd $cmdinst[2]
			ret=$?
			if [[ $ret -eq 0 ]]; then
				if [[ -n "$color" ]]; then
					color $fullcmd
				else
					$fullcmd
				fi
				ret=$?
			fi
		fi
		if [[ -n $DEBUG ]]; then
			typeset +tf $cmd || set +x
			return $ret
		fi

		if ! in_array okcodes $ret; then #TODO
			if [[ -n "$trysudo" ]]; then
				techo "Trying with sudo"
				color sudo $fullcmd
				ret=$?
			fi
			in_array okcodes $ret || throw $ret
		fi
	} always {
		if catch '*'; then
			local data=(${=CAUGHT})
			ret=$data[1]
			if [[ $ret -eq 130 ]]; then
				cancel $verbose "$print $CANCEL"
				return
			fi
			[[ $verbose -ge 1 ]] && techo "$print $FAIL ($data)"
			[[ -n "$alert" ]] && error "$print error: $data"
			abort $skipErrors $ret
			return
		fi
	}

	case $ret in
	0)
		[[ $verbose -ge 4 ]] && techo "$cmd $OK"
		[[ -n "$alert" ]] && success "$cmd finished successfully."
	;;
	*)
		[[ $verbose -ge 1  ]] && techo "$print $FAIL"
		[[ -n "$alert" ]] && error "$print error: ret=$ret"
		abort $skipErrors $ret
	;;
	esac

	return $ret
}

# nice fonts:
# smaller: pagga, future
# medium: smblock
function banner()
{
	local cmd c
	if type toilet >/dev/null; then
		cmd='toilet'
	elif type figlet>/dev/null; then
		cmd='figlet'
	else
		if type apt-get 2>&1 >/dev/null && sudo apt install toilet lolcat; then
			if type toilet >/dev/null; then
				cmd='toilet'
			fi
		elif type yum >&/dev/null; then
			sudo yum install figlet && cmd='figlet'
		fi
	fi
	if [ "$1" = '-c' ]; then
		c=$2 ; shift 2
	fi
	if [ -z "$cmd" ]; then
		if [ -n "$c" ]; then
			techo -c $c "$@"
		elif type lolcat >/dev/null; then
			echo "$@" | lolcat -F 0.3 -a -s 40 -d 4 >$TTY
		fi
		return
	fi
	
	if [ -n "$c" ]; then
		$cmd -f pagga "$@" | colorify -c $c >$TTY
	elif type lolcat >/dev/null; then
		$cmd -f pagga "$@" | lolcat -F 0.3 -a -s 40 -d 4 >$TTY
	else
		$cmd -f pagga "$@" >$TTY
	fi
}
function group()
{
	local line opt
	local integer i=0 num=${1:-1}
	zparseopts -D -M - g:=opt

	[[ -n $opt ]] && num=$opt[2]
	while read -r line; do
		echo $line
		((++i % num == 0)) && echo ――――――――――――――――――――――――
	done
}
function color()
{
	{ "$@" 2>&1 1>&3 | sed $'s,.*,\e[91m&\e[0m,' 1>&2 } 3>&1
	return $pipestatus[1]
}

function colorify()
{
	local line data debug
	zparseopts -D -M - d:=debug
	#@broken: [ ! -p /dev/stdin ] && exit 0
	if [ "$1" = '-all' ] || [ "$1" = '-c' ]; then
		if [ "$1" = '-all' ]; then
			c='err'
		else
			c=$2
			shift
		fi
		shift
		if [[ -n $1 ]]; then
			data=("${(@f)@}")
			for line in $data; do
				echo "${C[$c]}$line$C_"
			done
		else
			while read line; do
				echo "${C[$c]}$line$C_"
			done
		fi
	else
		local a cmd
		if [[ -n $debug ]]; then
			cmd=$debug[2]
			while read line; do
				if [[ $line =~ ^\\+$cmd:([0-9]+)\>\ (.*) ]]; then
					techo -c lcyan $cmd:$match[1] ${_C}$match[2]
				elif [[ $line =~ ^\\+([[:alnum:]]+):([0-9]+)\>\ (.*) ]]; then
					techo -c blue $match[1]:$match[2] ${_C}$match[3]
				else
					techo $line
				fi
			done
		else
			while read line; do
				techo $line
			done
		fi
#			debug=$(cat)<<-END
#				function dbg(c,name,line,str) {
#					printf("\033[%dm%s\033[1m%s\033[0m> %s\n",90+c,name,line,str)
#				}
#				/^\+${debug[2]}:([0-9]+)> (.*)/ {dbg(5,"${debug[2]}",\$1,\$2);next}
#				/^\+([[:alnum:]]+):([0-9]+)> (.*)\\n/ {dbg(6,\$1,\$2,\$3);next}
#			END
#		fi
#		a=$(cat)<<-END
#		BEGIN{IGNORECASE=1}
#		function color(c,s) {
#			printf("\033[%dm%s\033[0m\\n",90+c,s)
#		}
#		$debug
#		/\.php/ {color(2,\$0);next}
#		/error/ {color(1,\$0);next}
#		/success/ {color(2,\$0);next}
#		/warning/ {color(3,\$0);next}
#		/INFO/ {color(4,\$0);next}
#		/DBG/ {color(5,\$0);next}
#		{print}
#		END
#		echo "a=${(qqq)a}"
#		awk -D -f <(<<< ${(q)a}) </dev/stdin
	fi
}

# Added 2019-05-08 23:55
function refactor()
{
	local dir=${1:-.}
	#run -S find . -type f -name '*.php' -exec perl -pi -e "s/$search/$replace/g" {} +
	run -S grep < <(
		find $dir -type f -name '*.php' -print0 | xargs -0 sed "s/$search/${C[cyan]}${replace}${_C}/g"
	)
	confirm Replace || abort
	find $dir -type f -name '*.php' -print0 | xargs -0 sed -ised "s/$search/$replace/g"
}

alias q=queue
# Added 2019-06-04 17:47
function queue()
{
	local qid qFilter cmd queue queues dir baseDir=$CFG e="q"
	zparseopts -D -M - d:=dir -dir:=d
	if [[ $# -eq 0 ]]; then
		cmd='show'
	else
		cmd=$1; shift
		if [[ -n $1 ]]; then
			qFilter=$1
			shift
		fi
	fi
	if [[ $#dir[2] -ne 0 ]]; then
		dir=$dir[2]
	else
		dir=$baseDir
	fi
	[[ -d $dir ]] || abort 127 "\"$dir\": directory not found"
	[[ -z $qFilter ]] && qFilter="*.$e"

	include file
	case $cmd in
		add)
			#queues=($dir/$~qFilter(-N))
			queues=($dir/*(-N))
			queue=$(chooser -S $qFilter $queues:t "New queue" "Browse full path") || cancel
			if [[ "$queue" == "New queue" ]]; then
				queue=$(input -p "Enter queue id") || cancel
				[[ ${queue:0:1} != / ]] && queue=$dir/$queue
				[[ ${queue: -2} != ".$e" ]] && queue=$queue.$e
			elif [[ "$queue" == "Browse full path" ]]; then
				queue=$(chooser --file -p "Choose path of queue") || cancel
				[[ ${queue:0:1} != / ]] && queue=$dir/$queue
				#dir=$(getfilename $queue)
			fi
			qid=$(noext $(getfilename $queue) $e)
			input -p "Adding to $qid" "$@" >> $queue || cancel
			;;
		show)
			for queue in $dir/$~qFilter(-N); do
				qid=$(noext $(getfilename $queue) $e)
				run -p "Queue: $qid" show $queue
			done
			;;
		*)
			techo -c err "$cmd: invalid command"
			usage
	esac

	function usage() {
		techo -c warn "$0 [--dir/-d path] <add|show> [searchFilter]\n\
			default filter: *.q\n\
			default dir: $baseDir"
	}
}

# Added 2019-09-20 15:55
function pizza()
{
	local integer mins=13
	local msg

	{ while (( mins )); do
		msg="$mins minutes left to pizza time"
		techo $msg
		sleep 60
		((mins--))
	done ; alert "pizza time" } &
}

