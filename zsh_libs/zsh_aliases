VERSION=1.0.7
[[ -v comp ]] || typeset -g -a comp
alias e=echo
alias op='open'
alias vmake="make SHELL='$SHELL -x'"
alias sv="v -s"
alias cfg="cd $CFG"
alias s="do_sudo"
alias apt="sudo apt"
alias sys="sudo systemctl"
alias c='cod'
alias wh='what'

[[ -z $VIM && $SHELL == '/bin/zsh' ]] || return

function cod()
{
	local opts arg args linenum file pos tmp

	for arg in "$@"; do
		if [[ "$arg" =~ ":" ]]; then
			explode -v tmp $arg ':'
			file=$tmp[1]
			linenum=$tmp[2]
			if ((linenum)); then
				pos=+$linenum
			fi
			code $opts $pos $file
		else
			code $opts $arg
		fi
	done
}

function what()
{
	which $1

}

function hg()
{
	local match fopt gopt ic range
	zparseopts -D - i=ic r:=range
	#gopt+=($ic ${@#-[]})
	gopt+=($ic)
	[[ -n $range ]] && fopt=${range[2]} || fopt="0"
	#@TODO
	fc -li ${=fopt} | egrep ${=gopt} -- $1
}

# Added 2019-04-12 11:45
function aptlist()
{
	zgrep 'install ' /var/log/dpkg.log* | sort | cut -f1,2,4,6 -d' ' | less
}

function zindent()
{
	integer f
	[[ $# -gt 1 ]] && {
		f=1
		echo "function $1()\n{"
		shift
	}
	echo "$@" | sed -E 's/^([^{}])/\t\1/g'
	((f)) && echo "}"
}

function mkscript()
{
	local shell func name edit append ret=1
	local file isLib help line data data2 _type
	zparseopts -D -K s:=shell f:=func n:=name e=edit

	(($#func)) && func=$func[2]
	data2="$@"
	while ((ret)); do
		input -p "Function name" -v func || cancel
		if (($#func)); then
			_type=($(typeOf -a $func))
			if in_array 'function' _type; then
				local tmp=$functions_source[$func] options
				options=(Rename Append "Edit $func()" Cancel)
				if [[ -z $tmp ]]; then
					if explode -v tmp $functions[$func] $'\n' 1 && \
						[[ $tmp == *'include '(#b)([a-zA-Z]##)" && {" ]]
					then
						tmp=zsh_$match[1]
					else
						tmp='anonymous'
						options=(Rename 'Use it' Cancel)
					fi
				fi
				#if [[ $arg[4] == 'autoload' ]]; then
				#	autoload +X $1 && edfunc $1
				#	return

				techo -c warn "$func() already exists ($tmp)"
				chooser -v tmp -f1 -p "$func() already exists ($tmp)" $options || cancel

				case $tmp in
					Edit)
						vw $func && return
						ret=0
						;;
					Append)
						ret=0
						append=1
						;;
					Cancel)
						cancel
						;;
					Rename)
						;;
					Use)
						data2="$functions[$func]"
						ret=0
						;;
					*) abort -D-1 9 "Unknown option '$tmp'" ;;
				esac
			elif in_array 'command' _type; then
				techo -c warn "Command $func exists"
			else
				ret=0
			fi
		fi
	done

	isLib=0
	if [[ -n "$name" ]]; then
		local err_exists="exists but isn't a shell script."
		name=$name[2]
        if [[ $(getpath $name) != '.' || $name == ./* ]]; then # full path given
			if [[ -d $name ]]; then
				echo "$name is a directory"
				return 1
			elif [[ -f $name ]] && ! isScript $name; then
				echo "$name $err_exists"
				return 1
			fi
			file=$name
		else
			cmdtype=($(typeOf $name))
			type=${cmdtype[1]}
			file=${cmdtype[2]}
			name=${name#zsh_*}
			if [[ $type != "script" ]]; then
				if [[ -f "$ZSH_LIBS/zsh_$name" ]]; then # is it a lib?
					file="$ZSH_LIBS/zsh_$name"
					isLib=1
				elif [[ "$type" != 'none' ]]; then
					echo "$file $err_exists"
					return 1
				else
					file="$ZSH_LIBS/zsh_$name"
					isLib=1
				fi
			fi
		fi
	else
		isLib=1
		file="$(chooser $ZSH_LIBS/zsh_*(-N) "New zsh library" "Browse full path")" || cancel
		if [[ "$file" == "New zsh library" ]]; then
			input -v file -p "Enter new library name" 'zsh_' || cancel
		elif [[ "$file" == "Browse full path" ]]; then
			#@TODO
			chooser -v file --head "Choose path of zsh library" --dir || cancel
		fi

		name=$(getfilename $file)
		name='zsh_'${name#zsh_*}
		if [[ $file == */* ]]; then
			file=$(getpath $file)/$name
		else
			file=$ZSH_LIBS/$name
		fi
	fi

	if [[ ! -f "$file" ]]; then
		# Create library
		if ((isLib)); then
			data=$(< $ZSH_LIBS/zsh_blank)
		else
			# Create script
			[[ -n $shell ]] && shell="/bin/"$shell[2] || shell=$SHELL
			data="#!${shell}"
		fi
	fi

	# add data
	# TODO: append to function in case of existing function
	data+="\n# Added "$(date "+%F %R")"\n"
    if [[ -n $func ]]; then
		data+=$(zindent $func "$data2")
	else
		line=$(wc -l $file)
		data+=$(zindent "$data2")
	fi

	echo -n $data >> $file
	((isLib)) && source $file && { type $func ; which $func; }

	# setup file
	[[ -x $file || $isLib -eq 1 ]] || chmod +x $file

	# edit
	if [[ -n $edit || -z $data2 ]] || confirm "Edit file"; then
		if (($#func && isLib)); then
			edfunc $func
		else
			v -f $file
		fi
	fi
}
#function _stack()
#{
#	declare -A stack
#}
# args: name commandline options

function gvimdiff()
{
	integer ret
	diff -u $1 $2
	ret=$?
	if ((ret==0)); then
		techo "$1 == $2"
	elif ((ret == 1)); then
		command gvimdiff $1 $2
	fi
}

function emu()
{
    v /media/sparc/retropie/opt/retropie/emulators/retroarch/retroarch.cfg
    xdg-open https://github.com/retropie/retropie-setup/wiki/retroarch-configuration
    xdg-open http://www.instructables.com/id/USB-SNES-Controller/
}
function add_key()
{
	base=${1:-~}
	cat $CFG/id_rsa.pub > ${base}/.ssh/authorized_keys
	chmod 700 ${base}/.ssh
	chmod 600 ${base}/.ssh/authorized_keys
}

function edalias()
{
	local linenum pat file var isFunc
	zparseopts -D -M l:=linenum f=isFunc
	[[ -n $1 ]] || return 1
	if (($#isFunc)); then
		pat="(function +)?$1\(\)"
		linenum=${linenum[2]:-2}
	else
		pat="alias +$1=['\"].*['\"]"
		linenum=0
	fi
	if (($#2)); then
		file=$2
		#var=("${(@f)$(egrep -rHn "^([^#]* )?$pat" $file)}") || var=($file:0)
		if ! var=("${(@f)$(egrep -rHn "^([^#]* )?$pat" $file)}"); then
			[[ $(getfilename $file) == $1 ]] && var=($file:0)
		fi
	else
		var=("${(@f)$(egrep -rHn --exclude tags "^([^#]* )?$pat" $ZSH_LIBS $fpath)}")
	fi

	if [[ -n $var[1] ]]; then
		local result line col=0 opts i=1
		typeset -a tmp opts

		if (($#var > 1)); then
			for result in $var; do
				explode -v tmp "$result" ':'
				file=$(getfullpath -r . $tmp[1])
				line=${tmp:2}
				opts+=("$i $file $line")
				((i++))
			done
			i=$(chooser -f1 $opts) || cancel
		fi
		result=$var[$i]
		explode -v tmp "$result" ':'
		file=$tmp[1]
		if ((tmp[2])); then
			[[ ${tmp:2} =~ $pat ]] && {
				((MBEGIN > 1)) && col=$MBEGIN
				# @TODO
				#echo $MATCH $match "{$MBEGIN $MEND} {$mbegin[1] $mend[1]}"
			}
			((linenum+=$tmp[2]))
			file+=:$linenum
			((col)) && file+=:$col
			v $file
		else
			v $file
		fi
	else
		if (($#isFunc)); then
			techo -c err "Could not find function $1()"
		else
			techo -c err "Could not find alias $1"
		fi
	fi
}

function edfunc()
{
	local arg file
	arg=($(type $1)) || return 1
	if [[ "${arg[4]}" == 'autoload' ]]; then
		autoload +X $1 && edfunc $1
		return
	elif [[ $arg[5] != 'function' ]]; then
		if [[ $arg[4] == 'alias' ]] && (($#functions[$1])); then
			file=$functions_source[$1]
		else
			abort 2 "$1 is not a function:\n\t$arg"
		fi
	elif [[ -f $arg[-1] ]]; then
		file=$arg[-1]
	else
		techo "$1 is anonymous function:"
		local tmp=$(which $1)
		techo -c warn $tmp
		if [[ $tmp =~ 'include ([-a-z_]+)' ]]; then
			file=$match[1]
			if [[ $file = */* ]]; then
				file=$(getfullpath $file)
			else
				file="$ZSH_LIBS/zsh_"${file#zsh_}
			fi
		fi
	fi
	edalias ${2:+-l $2} -f "$1" "$file"
}

comp+=("vw=exec")
function vw()
{
	local array mime cpath name linenum
	array=($(explode "$1" ':')) ; name=$array[1]; linenum=$array[2]
	array=($(type -w "$name"))
	case "${array[2]}" in
		none)
			[[ -f $name ]] || abort 127 'Command not found'
			v $name:$linenum
			;;
		function)
			edfunc $name $linenum
			;;
		alias)
			local func
			if (( $+functions[$name] )); then # also a function exists
				local opt
				(( $#linenum )) && { edfunc $name $linenum ; return }
				func=$name
			else
				if [[ $(type $name) =~ "^$name is an alias for (.*)$" ]]; then
					func=$(inAlias -f $name)
				fi
			fi

			if (($#func)); then
				opt=$(chooser -f1 "alias $name" "function $func()") || cancel
				[[ $opt == 'function' ]] && { edfunc $func $linenum ; return }
			fi
			edalias $name $linenum
			;;
		command)
			cpath=$(which "$name")
			if [[ -f $cpath ]]; then
				mime=$(getmime $cpath)
				if [[ $mime == 'application/x-sharedlib' ]]; then
					echo "$cpath is binary executable"
					return 1
				fi
				v $cpath ${linenum:++$linenum}
			else
				echo Invalid path \"$cpath\"
			fi
			;;
	esac
}

# call vim to each file:linenum argument
# file1:l4 file2:l66
function v()
{
	local opts sudo arg args vim linenum
	#typeset -aU
	if [[ -n $DISPLAY ]]; then
		vim=gvim
	else
		vim=vim
	fi
	while (($#)); do
		if [[ ${1:0:1} == '-' ]]; then
			case $1 in
				-s) sudo=(sudo)
					;;
				-#) opts+=('+/^\s*[^#]')
					;;
				-f) [[ -n $DISPLAY ]] && opts+=(-f)
					;;
				-) opts+=(-u NONE -N)
					;;
				*) opts+=($1)
					;;
			esac
		else
			args+=($1)
		fi
		shift
	done

	for arg in $args; do
		if [[ "$arg" =~ ":" ]]; then
			local tmp pos file
			explode -v tmp $arg ':'
			file=$tmp[1]
			linenum=$tmp[2]
			if ((tmp[3])); then
				pos="+call cursor($linenum,$tmp[3])"
			elif ((linenum)); then
				pos=+$linenum
			fi
			$sudo $vim $opts $pos $file
		else
			$sudo $vim $opts $arg
		fi
	done
}

function cptree()
{
	local dest=$1
	shift
	echo $@ | cpio -pdv $dest
}
function loadvim()
{
	set -x
	list=${1:-vimlist.txt}
	dirs=(. $CFG)
	v -p $(cat `find ${dirs[*]} -name $list`)
	set +x

}
function savevim()
{
	list=$(forvim "expand('%:p')")
	echo $list
	echo $list > $CFG/vimlist.txt
}
function vimcmd()
{
	--remote-send $@
}
function forvim()
{
	local _v _cmd
	if [ "$1" = "cmd" ]; then
		_cmd="--remote-send"
		shift
	else
		_cmd="--remote-expr"
	fi
	for _v in `vim --serverlist`; do
		vim --servername $_v $_cmd $@
	done
}
function f()
{
	local d i s p g base args name n=1
	zparseopts -D - d:=d i=i s=s p=p g:=g b:=base
	[[ -n $s ]] && s="sudo"
	[[ -n $d ]] && d[1]='-maxdepth'
	[[ -n "$base" ]] && explode -v base "$base[2]" ',' || base=(.)
	#[[ $1 = - ]] && shift
	#$s find ${=d} \( -path ./bckup_extensions -or -path ./extensions \) -prune -or $name $@ -print
	local found arg
	until (( found )) || [[ -z ${arg::=${@:$n:1}} ]]; do
		[[ $arg[1] == '-' ]] && ((found=n))
		((n++))
	done

	if ((found==0 || found>1)); then
		((found==0)) && args=("$@") || args=(${@:1:$found-1})
		[[ -n $i ]] && name="-iname" || name="-name"
		name=($name' '${^args})
		shift $#args
	fi
	[[ -n $g ]] && {
		$s find -L $base ${=d} ${=name} $@ $p | group $g
	} || $s find -L $base ${=d} ${=name} $@ $p
}
function aldd() {
	local R=$USER_HOME/clp
	if [[ $# -gt 1 ]]; then
		if [ "$1" = "-r" ]; then
			shift
			R=$1
			shift
		elif [ "$1" = "-s" ]; then
			R=$STAGING_DIR
			shift
		fi
	fi
	${TOOLCHAIN_SYS}ldd --root=$R $@
}

function recv()
{
	local host=$1
#	scp $host:$2
	echo TODO
}

function send()
{
	local host=$1
	shift
	scp $@ $host
}

function ge()
{
	local sudo icase in_exts ex_exts ex_dirs width prefix
	local opts args defExDirs defExExts _opts
	zparseopts -D -E -M -A _opts - i=icase s=sudo -exclude:=ex_exts E:=ex_dirs \
		W::=width -cols::=W

	opts=()
	IFS=',;: ' read -rA in_exts <<<"$1"
	shift
	#	exc=("--exclude-dir=extensions" "--exclude-dir=bckup_extensions")
	opts+=('--include=*.'${^in_exts[@]})
	if (($#ex_exts)); then
		IFS=',;: ' read -rA ex_exts <<<$ex_exts[2]
		opts+=('--exclude=*.'${^ex_exts[@]})
	fi
	(($#ex_dirs)) || ex_dirs=(- node_modules,android,vendor)
	if (($#ex_dirs)); then
		IFS=',;: ' read -rA ex_dirs <<<$ex_dirs[2]
		techo "Excluding dirs: $ex_dirs"
		opts+=('--exclude-dir='${^ex_dirs[@]})
	fi
	opts+=(--color=always $icase)
	if [[ -n $sudo ]]; then
		prefix='sudo'
	else
		prefix='command'
	fi
	if (($#width)); then
		# -wN
		(($#width[1] > 2)) && width=${width[1]:2} || width=0
		if ((!width)); then
			$prefix grep -rn $opts "$@"
			return
		fi
	else
		((width=$(tput cols)+50))
	fi
	$prefix grep -rn $opts "$@" | cut -c1-$width

	if (($pipestatus[1] && $#ex_dirs)); then
		if confirm 'Retry without exclusions?'; then
			opts=('--include=*.'${^in_exts[@]} --color=always $icase)
			$prefix grep -rn $opts "$@" | cut -c1-$width
		fi
	fi
}

function duh()
{
	local sudo
	[[ "$1" == '-s' ]] && { shift; sudo='sudo'; }
	$sudo du -csh "$@" | sort -h
}

# Added 2019-01-11 16:33:46
function stripcolors()
{
	local sreg="s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g"
	if (($#)); then
		if [[ -f $1 ]]; then
			sed -r $sreg $1
		else
			echo $@ | sed -r $sreg
		fi
	else
		sed -r $sreg -
	fi
}

# Added 2019-01-11 17:00:37
function shpydf()
{
    output=`pydf`; devs=`echo $output | cut -f1 -d' ' `; labels=`sudo lsblk --noheadings -o LABEL $devs|stripcolors`; for line in $output; do i=1; echo "${labels[$i]} $line"; i++; done
}

# Added 2019-02-20 15:38:03
function hidrivemount()
{
    local mnt="/mnt/webdav.$USER"
    [[ -d $mnt ]] || sudo mkdir -p $mnt
    sudo mount -t davfs https://webdav.hidrive.strato.com/ $mnt
}

# Added 2019-02-25 08:36:38
function find_dupes()
{
	local dupes
	echo TODO: test against fdupes speed
#	dupes=(find . ! -empty -type f -exec md5sum {} + | sort -k1 | uniq -w32 -D --all-repeated=separate)
	#getpath $(printf "%s\n" "$string1" "$string2" | sed -e 'N;s/^\(.*\).*\n\1.*$/\1/'
}

# Added 2019-03-30 20:31
function lastarg()
{
	echo ${@: -1}
}

# Added 2019-03-30 20:31
function mkcd()
{
	local dir=$(lastarg "$1")
	mkdir -p "$dir"
	cd "$dir"
}

# Added 2019-03-30 20:31
function mkcp()
{
	local dir=$(lastarg "$@")
	mkdir -p "$dir"
	cp "$@"
}

# Added 2019-04-11 01:43
function logs()
{
	[[ $1 == 'off' ]] && { killall tail; return }
	run tail $(git root)/logs/{api,debug,php}.txt -f &
}

# Added 2020-01-14 21:06
function fixtty()
{
	# show cursor
	tput cnorm # or echo -en "\e[?25h"
	confirm 'Reset terminal' && tput reset
}
