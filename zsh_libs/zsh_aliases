VERSION=1.0.7
[[ -v comp ]] || typeset -g -a comp
alias e=echo
alias up='xdotool key Ctrl+Shift+F type ❯ ; xdotool key F3 key F3' # find last prompt
alias up='xdotool key Ctrl+Shift+F type ❯ ; xdotool key Shift+F3 key Shift+F3' # find last prompt
alias op="xdg-open"
alias open="xdg-open"
alias vmake="make SHELL='$SHELL -x'"
alias web="cd gp3320/app/bcm-webconf ; . venv/bin/activate ; ./webconf.py &"
alias sv="v -s"
alias cfg="cd $CFG"
alias s="sudo"
alias cpa="sudo cp -a"
alias mk="make"
alias apt="sudo apt"
alias diff_ignore_space="diff --ignore-space-change --ignore-tab-expansion --ignore-trailing-space --ignore-blank-lines"
alias sys="sudo systemctl"
#alias jtags="ctags -R . && sed -i -E '/^(if|switch|function|module\.exports|it|describe).+language:js$/d' tags"
alias jtags='find . -type f -iregex ".*\.js$" -not -path "./node_modules/*" -exec jsctags {} -f \; | sed '"'"'/^$/d'"'"' | LANG=C sort > tags2'
alias pytags="ctags -R --python-kinds=-i ."

function tags()
{
	local lang args
	zparseopts -lang:=lang
	if (($#)) && [[ ! -f $1 && -z $lang ]]; then
		lang=$1
		shift
	elif [[ -n $lang[2] ]]; then
		lang=$lang[2]
	else
		lang=$(chooser Javascript PHP Python Shell) || cancel
	fi

	#args=${@:-
	case ${(L)lang} in
		javascript|js) jtags ;;
		php) phpctags -R --exclude='vendor/*' $args ;;
		python|py) pytags ;;
		shell|sh) ctags --language-force=Sh -R . ;;
		*) techo -c err "Unsupported language: $lang" ;;
	esac
}

function hg()
{
	local match fopt gopt ic range
	zparseopts -D - i=ic r:=range
	#gopt+=($ic ${@#-[]})
	gopt+=($ic)
	[[ -n $range ]] && fopt=${range[2]} || fopt="0"
	#@TODO 
	fc -li ${=fopt} | egrep ${=gopt} -- $1
}

# Added 2019-04-12 11:45
function aptlist()
{
	zgrep 'install ' /var/log/dpkg.log* | sort | cut -f1,2,4,6 -d' ' | less
}

function mkscript()
{
	local shell func name edit
	local file isLib help line data data2 _type
	zparseopts -D -K s:=shell f:=func n:=name e=edit
	
	data2="$@"
	if [[ -n $func[2] ]]; then
		func=$func[2]
		_type=($(typeOf $func))
		(($#_type))
		if [[ "" == 'function' ]]; then
			techo -c warn "$func() already exists"
			vw $func
			return
		fi
		#@TODO function already exists? (c)ancel, (e)dit, (o)verwrite
	fi
	input -p "Function name" -v func
	isLib=false
	if [[ -n "$name" ]]; then
		local err_exists="exists but isn't a shell script."
		name=$name[2]
		file=$(getpath $name)
        if [[ "$file" != "." ]]; then # full path given
			if [[ -d "$name" ]]; then
				echo "$name is a directory"
				return 1
			elif [[ -f "$name" ]] && ! isScript $name; then
				echo "$name $err_exists"
				return 1
			fi
			file=$name
		else
			cmdtype=($(typeOf $name))
			type=${cmdtype[1]}
			file=${cmdtype[2]}
			name=${name#zsh_*}
			if [[ "$type" != "script" ]]; then
				if [[ -f "$ZSH_LIBS/zsh_$name" ]]; then # is it a lib?
					file="$ZSH_LIBS/zsh_$name"
					isLib=true
				elif [[ "$type" != 'none' ]]; then
					echo "$file $err_exists"
					return 1
				else
					file="$ZSH_LIBS/zsh_$name"
					isLib=true
				fi
			fi
		fi
	else
		isLib=true
		file="$(chooser $ZSH_LIBS/zsh_*(-N) "New zsh library" "Browse full path")" || cancel
		if [[ "$file" == "New zsh library" ]]; then
			file=$(input -p "Enter new library name" 'zsh_') || cancel
		elif [[ "$file" == "Browse full path" ]]; then
			file=$(chooser -p "Choose path of zsh library" --dir) || cancel
		fi

		name=$(getfilename $file)
		name='zsh_'${name#zsh_*}
		if [[ $file == */* ]]; then
			file=$(getpath $file)/$name
		else
			file=$ZSH_LIBS/$name
		fi
	fi

	if [[ ! -f "$file" ]]; then
		# Create library
		if isLib; then
			data="VERSION=1.0.0\n[[ -v comp ]] || typeset -g -a comp"
		else
			# Create script
			[[ -n "$shell" ]] && shell="/bin/"$shell[2] || shell=$SHELL
			data="#!${shell}\n"
		fi
	fi

	# add data
	# TODO: append to function in case of existing function
	data+="\n# Added "$(date "+%F %R")"\n"
    if [[ -n "$func" ]]; then
		data+=$(zindent $func "$data2")
	else
		line=$(wc -l $file)
		data+=$(zindent "$data2")
	fi

	echo ${data}$'\n' >> $file
	$isLib && source $file && { type $func ; which $func; }

	# setup file
	[[ -x "$file" || $isLib ]] || chmod +x $file

	# edit
	if [[ -n "$edit" || -z "$data2" ]] || confirm "Edit file"; then
		if [[ -n "$func" ]] && $isLib; then
			edfunc $func
		else
			gvim -f $file
		fi
	fi
}
#function _stack()
#{
#	declare -A stack
#}
# args: name commandline options

function gvimdiff()
{
	diff -u $1 $2
	if [ $? -eq 0 ]; then
		echo "$1 == $2"
	else
		command gvimdiff $1 $2
	fi
}

function emu()
{
    gvim /media/sparc/retropie/opt/retropie/emulators/retroarch/retroarch.cfg
    xdg-open https://github.com/retropie/retropie-setup/wiki/retroarch-configuration
    xdg-open http://www.instructables.com/id/USB-SNES-Controller/
}
function add_key()
{
	base=${1:-~}
	cat $CFG/id_rsa.pub > ${base}/.ssh/authorized_keys
	chmod 700 ${base}/.ssh
	chmod 600 ${base}/.ssh/authorized_keys
}

# finds command(s) in an alias
function inalias()
{
	local needsFunc ret=1 arr
	zparseopts -D -M - f=needsFunc
	if [[ $(type -f $1) =~ "^$1 is an alias for (.*)$" ]]; then
		local f m _type prefix=(run do_sudo) bins
		local integer command=0 glob=1 builtin=0
		for m in $=match[1]; do
			if [[ ${m:0:1} = [[:alpha:]] ]]; then
				_type=($(typeOf $m))

				if [[ $_type == 'none' ]]; then
					techo $m:none
					return 1
				fi

				if ((cmd)); then
					(($#needsFunc)) && return 1
					f=($(type -p $m))
					break
				elif ((builtin)); then
					_type='builtin'
					builtin=0
				fi

				if [[ $_type == 'builtin' ]]; then
					case $m in
						builtin) builtin=1
							;;
						command) cmd=1
							;;
						nocorrect)
							;;
						noglob) glob=0
							;;
						*) bins+=($m)
							;;
					esac
					continue
				fi

				in_array prefix $m && continue

				if [[ $_type == 'alias' ]]; then
					if [[ $m == $1 ]]; then
						if (($+functions[$m])) ; then
							f=$m
							break
						else
							return 1
						fi
					else
						tmp=($(inalias $needsFunc $m)) || return 1
						f=($tmp[1])
						break
					fi
				fi

				if (($#needsFunc)); then # needs function
					if (($+functions[$m])) ; then # found a function
						f=$m
						break
					else
						return 1
					fi
				else
					f=($m $_type[1])
					break
				fi
			fi
		done

		if (($#f)); then
			echo -n $f
			ret=0
		elif ((! $#needsFunc)); then
			ret=0
		fi
		(($#bins)) && echo $^bins":builtin"
	fi
	return $ret
}

function edalias()
{
	local linenum pat file var
	zparseopts -D -M l:=linenum
	[[ -n "$1" ]] || return 1
	if [[ "$1" == '-f' ]]; then
		shift
		pat="(function +)?$1\(\)"
		linenum=${linenum[2]:-2}
	else
		pat="alias +$1=['\"].*['\"]"
		linenum=0
	fi
	if (($#2)); then
		file=$2
		var=("${(@f)$(egrep -rHn "^([^#]* )?$pat" $file)}") || var=($file:0)
	else
		var=("${(@f)$(egrep -rHn "^([^#]* )?$pat" $ZSH_LIBS $fpath)}")
	fi
	
	if [[ -n $var[1] ]]; then
		local result line col=0 opts i=1
		typeset -a tmp opts

		if (($#var > 1)); then
			for result in $var; do
				explode -v tmp "$result" ':'
				file=$(getfullpath -r . $tmp[1])
				line=${tmp:2}
				opts+=("$i $file $line")
				((i++))
			done
			i=$(chooser -f1 $opts) || cancel
		fi
		result=$var[$i]
		explode -v tmp "$result" ':'
		file=$tmp[1]
		if ((tmp[2])); then
			[[ ${tmp:2} =~ $pat ]] && {
				((MBEGIN > 1)) && col=$MBEGIN
				# @TODO
				#echo $MATCH $match "{$MBEGIN $MEND} {$mbegin[1] $mend[1]}"
			}
			((linenum+=$tmp[2]))
			file+=:$linenum
			((col)) && file+=:$col
			v $file
		else
			v $file
		fi
	else
		techo -c err "Could not find \"$1\" alias"
	fi
}

function edfunc()
{
	local arg file
	arg=($(type $1)) || return 1
	if [[ "${arg[4]}" == 'autoload' ]]; then
		autoload +X $1 && edfunc $1
		return
	elif [[ $arg[5] != 'function' ]]; then
		if [[ $arg[4] != 'alias' ]] || (( ! $#functions[$1] )); then
			abort 2 "$1 is not a function:\n\t$arg"
		fi
		file=$functions_source[$1]
	else
		file="${arg[-1]}"
	fi
	edalias ${2:+-l $2} -f "$1" "$file" 
}
comp+=("vw=exec")
function vw()
{
	local array mime cpath name linenum
	array=($(explode "$1" ':')) ; name=$array[1]; linenum=$array[2]
	array=($(type -w "$name"))
	case "${array[2]}" in
		function)
			edfunc $name $linenum
			;;
		alias)
			local func
			if (( $#functions[$name] )); then # also a function exists
				local opt
				(( $#linenum )) && { edfunc $name $linenum ; return }
				func=$name
			else
				if [[ $(type -f $name) =~ "^$name is an alias for (.*)$" ]]; then
					func=$(inalias -f $name)
				fi
			fi

			if (($#func)); then
				opt=$(chooser -f1 "alias $name" "function $func()") || cancel
				[[ $opt == 'function' ]] && { edfunc $func $linenum ; return }
			fi
			edalias $name $linenum
			;;
		command)
			cpath=$(which "$name")
			if [[ -f "$cpath" ]]; then
				mime=$(getmime $cpath)
				if [[ "$mime" == "application/x-sharedlib" ]]; then
					echo "$tpath is binary executable"
					return 1
				fi
				gvim $cpath ${linenum:++$linenum}
			else
				echo Invalid path \"$cpath\"
			fi
			;;
	esac
}

# call vim to each file:linenum argument
# file1:l4 file2:l66 
function v()
{
	local opts sudo arg args skip
	while (($#)); do
		if [[ ${1:0:1} == '-' ]]; then
			if [[ $1 == '-s' ]]; then
				sudo='sudo'
			elif [[ $1 == '-#' ]]; then
				opts+=('+/^\s*[^#]')
			else
				opts+=($1)
			fi
		else
			args+=($1)
		fi
		shift
	done

	for arg in $args; do
		if [[ "$arg" =~ ":" ]]; then
			local tmp pos
			explode -v tmp $arg ':'
			file=$tmp[1]
			linenum=$tmp[2]
			if ((tmp[3])); then
				pos="+call cursor($linenum,$tmp[3])"
			elif ((linenum)); then
				pos=+$linenum
			fi
			$sudo gvim $opts $pos $file
		else
			$sudo gvim $opts $arg
		fi
	done
}

function finderror()
{
	errline=`tail /var/log/apache2/error.log |  grep -e "PHP \(Parse\|Fatal\|Notice\)" | tail -n1`
	str=`echo $errline| sed -e ':a' -e 'N' -e '$!ba' -e 's/\n/ /g'`
	linenum=`echo $str | sed 's/.*line \([0-9]*\).*$/\1/'`
	filename=`echo $str | sed 's/.*\(\/media\/sparc\/xdata\/[^ ]*\).*$/\1/'`
	echo $filename
	echo $linenum
	#v "$filename:$linenum"
}
function cptree()
{
	local dest=$1
	shift
	echo $@ | cpio -pdv $dest
}
function loadvim()
{
	set -x
	list=${1:-vimlist.txt}
	dirs=(. $CFG)
	gvim -p $(cat `find ${dirs[*]} -name $list`)
	set +x

}
function savevim()
{
	list=$(forvim "expand('%:p')")
	echo $list
	echo $list > $CFG/vimlist.txt
}
function vimcmd()
{
	--remote-send $@
}
function forvim()
{
	local _v _cmd
	if [ "$1" = "cmd" ]; then
		_cmd="--remote-send"
		shift
	else
		_cmd="--remote-expr"
	fi
	for _v in `vim --serverlist`; do
		vim --servername $_v $_cmd $@
	done
}
function f()
{
	local d i s p g base args name n=1
	zparseopts -D - d:=d i=i s=s p=p g:=g b:=base
	[[ -n $s ]] && s="sudo"
	[[ -n $d ]] && d[1]='-maxdepth'
	[[ -n "$base" ]] && explode -v base "$base[2]" ',' || base=(.)
	#[[ $1 = - ]] && shift
	#$s find ${=d} \( -path ./bckup_extensions -or -path ./extensions \) -prune -or $name $@ -print
	local found arg
	until (( found )) || [[ -z ${arg::=${@:$n:1}} ]]; do
		[[ $arg[1] == '-' ]] && ((found=n))
		((n++))
	done

	if ((found==0 || found>1)); then
		((found==0)) && args=("$@") || args=(${@:1:$found-1})
		[[ -n $i ]] && name="-iname" || name="-name"
		name=($name' '${^args})
		shift $#args
	fi
	[[ -n $g ]] && {
		$s find -L $base ${=d} ${=name} $@ $p | group $g
	} || $s find -L $base ${=d} ${=name} $@ $p
}
function aldd() {
	local R=$USER_HOME/clp
	if [[ $# -gt 1 ]]; then
		if [ "$1" = "-r" ]; then
			shift
			R=$1
			shift
		elif [ "$1" = "-s" ]; then
			R=$STAGING_DIR
			shift
		fi
	fi
	${TOOLCHAIN_SYS}ldd --root=$R $@
}

function recv()
{
	local host=$1
#	scp $host:$2 
	echo TODO
}

function send()
{
	local host=$1
	shift
	scp $@ $host
}

function ge()
{
	local sudo icase args in_exts ex_exts width prefix
	zparseopts -D -E -M - i=icase s=sudo --exclude:=ex_exts C::=width -cols::=C
	IFS=',;:' read -rA in_exts <<<"$1"
	shift
	#	exc=("--exclude-dir=extensions" "--exclude-dir=bckup_extensions")
	(($#ex_exts)) && args+=('--exclude=*.'${^ex_exts[@]})
	args+=('--include=*.'${^in_exts[@]})
	args+=(--color=always)
	[[ -n $icase ]] && args+=('-i')
	if [[ -n $sudo ]]; then
		prefix='sudo'
	else
		prefix='command'
	fi
	if (( $#width )); then
		(($#width[1] > 2)) && width=${width[1]:2} || width=0
		if ((!width)); then
			$prefix grep -rn $args $@
			return
		fi
	else
		#width=$(( $(tput cols) - 50 ))
		width=300
	fi
	$prefix grep -rn $args $@ | cut -c1-$width
}

function duh()
{
	local sudo
	[[ "$1" == '-s' ]] && { shift; sudo='sudo'; }
	$sudo du -csh "$@" | sort -h
}

# Added 2019-01-10 11:26:22
function extract_cpio_image()
{
    local ret name mime sourceDir imgfile=$(getfullpath "$1") targetroot targetDir uncompressed tmp
	[[ -n $imgfile ]] || abort 1 "No image given"
	[[ -s $imgfile ]] || { abort 127 "$imgfile: not found" ; return; }
	sourceDir=$(getpath "$imgfile")
	name=${$(getfilename "${(L)imgfile%.img}")#u}
    targetDir=${2:-$PWD/$name}
    (
		if [[ -f "$targetDir" ]]; then
			# targetDir=${targetDir}
			techo -c warn "A file exists in place of target dir: \"$C[warn]$targetDir$C_\""
			return 1
			#targetDir=$(input "Choose another path/filename" "$targetDir")
		fi
		
		if [[ -d "$targetDir" ]]; then
			isEmptyDir "$targetDir" || {
				confirm "Dir $targetDir not empty. $C[lred]Remove files and continue" \
					|| { cancel ; return; }
				run -s rm -rf "$targetDir"/* || { abort $? ; return; }
			}
		else
			confirm Create dir '"$targetDir"' && \
				run -s mkdir -p "$targetDir" || { abort $? ; return; }
		fi
		#uncompressed="$imgfile.cpio"
		#if [[ "$imgfile" -ot "$uncompressed" ]] && [[ -s "$uncompressed" ]] && \
		#	! confirm -c warn "$uncompressed is newer than $imgfile\nOverwrite it"
		#then
		#	{ cancel ; return; }
		#fi
		mime=$(getmime "$imgfile")
		tmp="$imgfile"
		if [[ "$mime" == 'application/octet-stream' ]]; then
			mime=$(file "$imgfile")
			if [[ $mime =~ 'cpio archive' ]]; then
				uncompressed="$imgfile" # already a cpio file
				tmp=
			elif [[ $mime =~ 'u-boot' ]]; then
				tmp="$sourceDir/$name.img.gz"
				[[ -f "$tmp" ]] && rm -f "$tmp"
				run -S -p 'U-Boot image detected. Extracting ramdisk.' \
					dd if="$imgfile" of="$tmp" bs=64c skip=1
				mime=$(getmime "$tmp")
			fi
		fi
		
		techo cd $targetDir
		cd $targetDir || return
		if [[ -n "$tmp" ]]; then
			if [[ "$mime" == 'application/gzip' ]]; then
				run -s -p "cpio: inflating $tmp -> $PWD/" \
					cpio -idmv < <(run zcat "$tmp") || return
			else
				abort 2 "$tmp is not a gzip (mime=$mime)"
				return 1
			fi
		else
			run -s -p "cpio: inflating $uncompressed -> $PWD/" \
				cpio -idmv --file="$uncompressed" || return
		fi
    ) && cd $targetDir
}
function compress()
{
    local alg sudo
	[[ $1 == -s ]] && { sudo=sudo ; shift; }
	alg=$1 ; shift
    case "$alg" in
        "gzip")
            $sudo gzip -c < $1 > $2
            ;;

        "lzo")
            $sudo lzop $1 -o $2
            ;;

        *)
            $sudo minigzip < $1 > $2
            ;;
    esac
}

function compress_cpio_image()
{
    local sourceDir targetImg imgName compalg ignore var
	zparseopts -D - i:=ignore
	sourceDir=$1 ; [[ -z $sourceDir || $sourceDir = . ]] && sourceDir=$PWD
	targetImg=$(getfullpath "${2:-$sourceDir}.img")
	targetDir=$(getpath $targetImg)
	imgName=u${(C)$(getfilenoext $targetImg)}
	compalg=${3:-mzip}
	if [[ -n $ignore ]]; then
		explode -v ignore $ignore[2] ':'
		ignore=('-path ./'${^ignore})
		ignore="( ${(j. -o .)ignore} ) -prune -o -print"
	fi
	
	(techo cd $sourceDir ; cd $sourceDir && run compress -s $compalg \
		<(cpio -ov -H newc -R root:root < <(run -s find ${(z)ignore}) ) $targetImg
	) &&
		run mkimage -A arm -O linux -T ramdisk \
			-d $(getfullpath -r=$PWD $targetImg) $(getfullpath -r=$PWD $targetDir/$imgName)
}

# Added 2019-01-11 16:33:46
function stripcolors()
{
	echo $@ | sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g"
}

# Added 2019-01-11 17:00:37
function shpydf()
{
    output=`pydf`; devs=`echo $output | cut -f1 -d `; labels=`sudo lsblk --noheadings -o LABEL $devs|stripcolors`; for line in $output; do i=1; echo "${labels[$i]} $line"; i++; done
}

# Added 2019-01-16 19:18:20
# create progress bar
function pbar()
{
	include -r progress_bar || return 1
	pbar "$@"
}

# Added 2019-02-20 15:38:03
function hidrivemount()
{
    local mnt="/mnt/webdav.$USER"
    [[ -d $mnt ]] || sudo mkdir -p $mnt
    sudo mount -t davfs https://webdav.hidrive.strato.com/ $mnt
}

# Added 2019-02-25 08:36:38
function find_dupes()
{
	local dupes
	echo TODO: test against fdupes speed
#	dupes=(find . ! -empty -type f -exec md5sum {} + | sort -k1 | uniq -w32 -D --all-repeated=separate)
	#getpath $(printf "%s\n" "$string1" "$string2" | sed -e 'N;s/^\(.*\).*\n\1.*$/\1/'
}

# Added 2019-03-30 20:31
function lastarg()
{
	echo ${@: -1}
}

# Added 2019-03-30 20:31
function mkcd()
{
	local dir=$(lastarg "$1")
	mkdir -p "$dir"
	cd "$dir"
}

# Added 2019-03-30 20:31
function mkcp()
{
	local dir=$(lastarg "$@")
	mkdir -p "$dir"
	cp "$@"
}

# Added 2019-04-04 14:54
function ipfind()
{
	local user=${1:-debian} net
	net=192.168.0
	for ip in $(seq $(($last+1)) 254); do
		last=$ip
		ping -W3 -c1 $net.$ip && ssh $user@$net.$ip
		echo ret=$?
	done
}

# Added 2019-04-11 01:43
function logs()
{
	tail {.,$(git root)}/logs/{api,debug}.txt -f &
}
