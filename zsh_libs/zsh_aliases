VERSION=1.0.5
[[ -v comp ]] || typeset -g -a comp
alias e=echo
alias op="xdg-open"
alias open="xdg-open"
alias vmake="make SHELL='$$SHELL -x'"
alias web="cd gp3320/app/bcm-webconf ; . venv/bin/activate ; ./webconf.py &"
alias sv="v -s"
alias pytags="ctags -R --python-kinds=-i ."
alias cfg="cd $CFG"
alias s="sudo"
alias cpa="sudo cp -a"
alias mk="make"
alias apt="sudo apt"
alias diff_ignore_space="diff --ignore-space-change --ignore-tab-expansion --ignore-trailing-space --ignore-blank-lines"
alias sys="sudo systemctl"
#alias jtags="ctags -R . && sed -i -E '/^(if|switch|function|module\.exports|it|describe).+language:js$/d' tags"
alias jtags='find . -type f -iregex ".*\.js$" -not -path "./node_modules/*" -exec jsctags {} -f \; | sed '"'"'/^$/d'"'"' | LANG=C sort > tags2'


function hg()
{
	local match fopt gopt ic range
	zparseopts -D -E -K i=ic r:=range
	[[ -n "$ic" ]] && gopt+=" -i"
	gopt+=" $1"
	[[ -n "$range" ]] && fopt="${range[2]}" || fopt="0"
	fc -li ${=fopt} | grep ${=gopt}
}

# Added 2019-04-12 11:45
function aptlist()
{
	zgrep 'install ' /var/log/dpkg.log* | sort | cut -f1,2,4,6 -d' ' | less
}

function mkscript()
{
	local shell func name data data2 edit err_exists file isLib help
	err_exists="exists but isn't a shell script."
	zparseopts -D -K s:=shell f:=func n:=name e=edit || abort
	
	data2="$@"
	if [[ -n "$func[2]" ]]; then
		func=$func[2]
		if [[ "$(typeOf $func)" == 'func' ]]; then
			techo -c warn "$func() already exists"
			vw $func
			return
		fi
		#@TODO function already exists? (c)ancel, (e)dit, (o)verwrite
	fi
	input -p "Function name" -v func
	isLib=false
	if [[ -n "$name" ]]; then
		name=$name[2]
		file=$(getpath $name)
        if [[ "$file" != "." ]]; then # full path given
			if [[ -d "$name" ]]; then
				echo "$name is a directory"
				return 1
			elif [[ -f "$name" ]] && ! isScript $name; then
				echo "$name $err_exists"
				return 1
			fi
			file=$name
		else
			cmdtype=($(typeOf $name))
			type=${cmdtype[1]}
			file=${cmdtype[2]}
			if [[ "$type" != "script" ]]; then
				if [[ -f "$ZSH_LIBS/zsh_$name" ]]; then # is it a lib?
					file="$ZSH_LIBS/zsh_$name"
					isLib=true
				elif [[ "$type" != 'none' ]]; then
					echo "$file $err_exists"
					return 1
				fi
			fi
		fi
	else
		isLib=true
		file="$(chooser $ZSH_LIBS/zsh_*(-N) "New zsh library" "Browse full path")"
		if [[ "$file" == "New zsh library" ]]; then
			file=$(input -p "Enter new library name" 'zsh_') || cancel
		elif [[ "$file" == "Browse full path" ]]; then
			file=$(chooser -p "Choose path of zsh library" --dir) || cancel
		fi

		name=$(getfilename $file)
		name='zsh_'${name#zsh_*}
		if [[ $file == */* ]]; then
			file=$(getpath $file)/$name
		else
			file=$ZSH_LIBS/$name
		fi
	fi

	if [[ ! -f "$file" ]]; then
		# Create library
		if isLib; then
			data="VERSION=1.0.0\n[[ -v comp ]] || typeset -g -a comp"
		else
			# Create script
			[[ -n "$shell" ]] && shell="/bin/"$shell[2] || shell=$SHELL
			data="#!${shell}\n"
		fi
	fi

	# add data
	# TODO: append to function in case of existing function
	data+="\n# Added "$(date "+%F %R")"\n"
    if [[ -n "$func" ]]; then
		data+=$(zindent $func "$data2")
	else
		data+=$(zindent "$data2")
	fi

	echo ${data}$'\n' >> $file
	$isLib && source $file && { type $func ; which $func; }

	# setup file
	[[ -x "$file" || $isLib ]] || chmod +x $file

	# edit
	if [[ -n "$edit" || -z "$data2" ]] || confirm "Edit file"; then
		[[ -n "$func" ]] && $isLib && edfunc $func || gvim -f $file
	fi
}
#function _stack()
#{
#	declare -A stack
#}
# args: name commandline options

function gvimdiff()
{
	diff -u $1 $2
	if [ $? -eq 0 ]; then
		echo "$1 == $2"
	else
		command gvimdiff $1 $2
	fi
}

function emu()
{
    gvim /media/sparc/retropie/opt/retropie/emulators/retroarch/retroarch.cfg
    xdg-open https://github.com/retropie/retropie-setup/wiki/retroarch-configuration
    xdg-open http://www.instructables.com/id/USB-SNES-Controller/
}
function add_key()
{
	base=${1:-~}
	cat $CFG/id_rsa.pub > ${base}/.ssh/authorized_keys
	chmod 700 ${base}/.ssh
	chmod 600 ${base}/.ssh/authorized_keys
}
function edalias()
{
	local line pat file var is
	zparseopts -D -M l:=line
	[[ -n "$1" ]] || return 1
	if [[ "$1" == '-f' ]]; then
		shift
		pat="(function )?$1\(\)"
		line=${line[2]:-2}
	else
		pat="alias $1="
		line=0
	fi
	file=${2:-~/.zsh_aliases}
	var="$(egrep -n "^[[:space:]]*$pat" "$file")" || var="2:$file"
	if [[ $? -eq 0 ]]; then
		((line+=$(explode "$var" ':' 1)))
		gvim -f $file +$line
		echo "PPID=$PPID"
		include $file
	else
		techo -c err "Could not find \"$1\""
	fi
}

function edfunc()
{
	local arg file
	arg=($(type "$1"))
	[[ $? -ne 0 ]] && return 1
	if [[ "${arg[4]}" == 'autoload' ]]; then
		techo "autoload function todo: find not loaded autoload functions in fpath"
		file="${arg[-1]}"
		[[ -f "$file" ]] || {
			typeset -a files=($(f -b "${j.,.)fpath}" "$1"))
			file=$(chooser -p "Choose file" $files) || cancel
		}
	elif [[ "${arg[5]}" != 'function' ]]; then
		abort 2 "$1 is not a function:\n\t$arg"
	else
		file="${arg[-1]}"
	fi
	edalias ${2:+-l $2} -f "$1" "$file" 
}
comp+=("vw=exec")
function vw()
{
	local array mime cpath name line
	array=($(explode "$1" ':')) ; name=$array[1]; line=$array[2]
	array=($(type -w "$name"))
	case "${array[2]}" in
		function) edfunc $name $line
			;;
		alias) edalias $name $line
			;;
		command)
			cpath=$(which "$name")
			if [[ -f "$cpath" ]]; then
				mime=$(getmime $cpath)
				if [[ "$mime" == "application/x-sharedlib" ]]; then
					echo "$tpath is binary executable"
					return 1
				fi
				gvim $cpath ${line:++$line}
			else
				echo Invalid path \"$cpath\"
			fi
			;;
	esac
}
# call vim to each file:line argument
# file1:l4 file2:l66 
function v()
{
	local opt sudo
	if [ "${1:0:1}" = "-" ]; then
		if [[ $1 = -s ]]; then
			sudo='sudo'
		else
			opt=$1
		fi
		shift
	fi
	for arg; do
		if [[ "$arg" =~ ":" ]]; then
			line=+$(echo $arg | cut -d: -f2)
			file=$(echo $arg | cut -d: -f1)
			$sudo gvim $opt $line $file
		else
			$sudo gvim $opt $arg
		fi
	done
}

function finderror()
{
	errline=`tail /var/log/apache2/error.log |  grep -e "PHP \(Parse\|Fatal\|Notice\)" | tail -n1`
	str=`echo $errline| sed -e ':a' -e 'N' -e '$!ba' -e 's/\n/ /g'`
	line=`echo $str | sed 's/.*line \([0-9]*\).*$/\1/'`
	filename=`echo $str | sed 's/.*\(\/media\/sparc\/xdata\/[^ ]*\).*$/\1/'`
	echo $filename
	echo $line
	v --remote-tab-silent "$filename:$line"
}
function cptree()
{
	local dest=$1
	shift
	echo $@ | cpio -pdv $dest
}
function loadvim()
{
	set -x
	list=${1:-vimlist.txt}
	dirs=(. $CFG)
	gvim -p $(cat `find ${dirs[*]} -name $list`)
	set +x

}
function savevim()
{
	list=$(forvim "expand('%:p')")
	echo $list
	echo $list > $CFG/vimlist.txt
}
function vimcmd()
{
	--remote-send $@
}
function forvim()
{
	local _v _cmd
	if [ "$1" = "cmd" ]; then
		_cmd="--remote-send"
		shift
	else
		_cmd="--remote-expr"
	fi
	for _v in `vim --serverlist`; do
		vim --servername $_v $_cmd $@
	done
}
function f()
{
	local d i s p g base args name n=1
	zparseopts -D - d:=d i=i s=s p=p g:=g b:=base
	[[ -n $s ]] && s="sudo"
	[[ -n $d ]] && d[1]='-maxdepth'
	[[ -n "$base" ]] && explode -v base "$base[2]" ',' || base=(.)
	#[[ $1 = - ]] && shift
	#$s find ${=d} \( -path ./bckup_extensions -or -path ./extensions \) -prune -or $name $@ -print
	local found arg
	until (( found )) || [[ -z ${arg::=${@:$n:1}} ]]; do
		[[ $arg[1] == '-' ]] && ((found=n))
		((n++))
	done

	if ((found==0 || found>1)); then
		((found==0)) && args=("$@") || args=(${@:1:$found-1})
		[[ -n $i ]] && name="-iname" || name="-name"
		name=($name' '${^args})
		shift $#args
	fi
	[[ -n $g ]] && {
		$s find -L $base ${=d} ${=name} $@ $p | group $g
	} || $s find -L $base ${=d} ${=name} $@ $p
}
function aldd() {
	local R=$USER_HOME/clp
	if [[ $# -gt 1 ]]; then
		if [ "$1" = "-r" ]; then
			shift
			R=$1
			shift
		elif [ "$1" = "-s" ]; then
			R=$STAGING_DIR
			shift
		fi
	fi
	${TOOLCHAIN_SYS}ldd --root=$R $@
}

function recv()
{
	local host=$1
#	scp $host:$2 
	echo TODO
}
function send()
{
	local host=$1
	shift
	scp $@ $host
}
function sge()
{
	ge -s $@
}
function ge()
{
	local sudo icase args in_exts ex_exts width
	zparseopts -D -E - i=icase s=sudo --exclude:=ex_exts w::=width
	[[ -n $icase ]] && args+=('-i')
	[[ -n $sudo ]] && sudo=sudo
	IFS=',;:' read -rA in_exts <<<"$1"
	shift
	#	exc=("--exclude-dir=extensions" "--exclude-dir=bckup_extensions")
	[ "$#ex_exts" -gt 0 ] && args+=('--exclude=*.'${^ex_exts[@]})
	args+=('--include=*.'${^in_exts[@]})
	if (( $#width )); then
		[[ $width = -w[0-9]## ]] && width=${width[1]:2} || width=0
		if [[ $width -eq 0 ]]; then
			$sudo grep --color -rn $args $@
			return
		fi
	else
		#width=$(( $(tput cols) - 50 ))
		width=300
	fi
	$sudo grep --color -rn $args $@ | cut -c1-$width
}
function duh()
{
	local sudo
	[[ "$1" == '-s' ]] && { shift; sudo='sudo'; }
	$sudo du -csh "$@" | sort -h
}

# Added 2019-01-10 11:26:22
function extract_cpio_image()
{
    local ret name mime sourceDir imgfile=$(getfullpath "$1") targetroot targetDir uncompressed tmp
	[[ -n $imgfile ]] || abort 1 "No image given"
	[[ -s $imgfile ]] || { abort 127 "$imgfile: not found" ; return; }
	sourceDir=$(getpath "$imgfile")
	name=${$(getfilename "${(L)imgfile%.img}")#u}
    targetDir=${2:-$PWD/$name}
    (
		if [[ -f "$targetDir" ]]; then
			# targetDir=${targetDir}
			techo -c warn "A file exists in place of target dir: \"$C[warn]$targetDir$C_\""
			return 1
			#targetDir=$(input "Choose another path/filename" "$targetDir")
		fi
		
		if [[ -d "$targetDir" ]]; then
			isEmptyDir "$targetDir" || {
				confirm "Dir $targetDir not empty. $C[lred]Remove files and continue" \
					|| { cancel ; return; }
				run -s rm -rf "$targetDir"/* || { abort $? ; return; }
			}
		else
			confirm Create dir '"$targetDir"' && \
				run -s mkdir -p "$targetDir" || { abort $? ; return; }
		fi
		#uncompressed="$imgfile.cpio"
		#if [[ "$imgfile" -ot "$uncompressed" ]] && [[ -s "$uncompressed" ]] && \
		#	! confirm -c warn "$uncompressed is newer than $imgfile\nOverwrite it"
		#then
		#	{ cancel ; return; }
		#fi
		mime=$(getmime "$imgfile")
		tmp="$imgfile"
		if [[ "$mime" == 'application/octet-stream' ]]; then
			mime=$(file "$imgfile")
			if [[ $mime =~ 'cpio archive' ]]; then
				uncompressed="$imgfile" # already a cpio file
				tmp=
			elif [[ $mime =~ 'u-boot' ]]; then
				tmp="$sourceDir/$name.img.gz"
				[[ -f "$tmp" ]] && rm -f "$tmp"
				run -S -p 'U-Boot image detected. Extracting ramdisk.' \
					dd if="$imgfile" of="$tmp" bs=64c skip=1
				mime=$(getmime "$tmp")
			fi
		fi
		
		techo cd $targetDir
		cd $targetDir || return
		if [[ -n "$tmp" ]]; then
			if [[ "$mime" == 'application/gzip' ]]; then
				run -s -p "cpio: inflating $tmp -> $PWD/" \
					cpio -idmv < <(run zcat "$tmp") || return
			else
				abort 2 "$tmp is not a gzip (mime=$mime)"
				return 1
			fi
		else
			run -s -p "cpio: inflating $uncompressed -> $PWD/" \
				cpio -idmv --file="$uncompressed" || return
		fi
    ) && cd $targetDir
}
function compress()
{
    local alg sudo
	[[ $1 == -s ]] && { sudo=sudo ; shift; }
	alg=$1 ; shift
    case "$alg" in
        "gzip")
            $sudo gzip -c < $1 > $2
            ;;

        "lzo")
            $sudo lzop $1 -o $2
            ;;

        *)
            $sudo minigzip < $1 > $2
            ;;
    esac
}

function compress_cpio_image()
{
    local sourceDir targetImg imgName compalg ignore var
	zparseopts -D - i:=ignore
	sourceDir=$1 ; [[ -z $sourceDir || $sourceDir = . ]] && sourceDir=$PWD
	targetImg=$(getfullpath "${2:-$sourceDir}.img")
	targetDir=$(getpath $targetImg)
	imgName=u${(C)$(getfilenoext $targetImg)}
	compalg=${3:-mzip}
	if [[ -n $ignore ]]; then
		explode -v ignore $ignore[2] ':'
		ignore=('-path ./'${^ignore})
		ignore="( ${(j. -o .)ignore} ) -prune -o -print"
	fi
	
	(techo cd $sourceDir ; cd $sourceDir && run compress -s $compalg \
		<(cpio -ov -H newc -R root:root < <(run -s find ${(z)ignore}) ) $targetImg
	) &&
		run mkimage -A arm -O linux -T ramdisk \
			-d $(getfullpath -r=$PWD $targetImg) $(getfullpath -r=$PWD $targetDir/$imgName)
}

# Added 2019-01-11 16:33:46
function stripcolors()
{
	echo $@ | sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g"
}

# Added 2019-01-11 17:00:37
function shpydf()
{
    output=`pydf`; devs=`echo $output | cut -f1 -d `; labels=`sudo lsblk --noheadings -o LABEL $devs|stripcolors`; for line in $output; do i=1; echo "${labels[$i]} $line"; i++; done
}

# Added 2019-01-16 19:18:20
# create progress bar
function pbar()
{
	include -r progress_bar || return 1
	pbar "$@"
}

# Added 2019-02-20 15:38:03
function hidrivemount()
{
    local mnt="/mnt/webdav.$USER"
    [[ -d $mnt ]] || sudo mkdir -p $mnt
    sudo mount -t davfs https://webdav.hidrive.strato.com/ $mnt
}

# Added 2019-02-25 08:36:38
function find_dupes()
{
	local dupes
	echo TODO: test against fdupes speed
#	dupes=(find . ! -empty -type f -exec md5sum {} + | sort -k1 | uniq -w32 -D --all-repeated=separate)
	#getpath $(printf "%s\n" "$string1" "$string2" | sed -e 'N;s/^\(.*\).*\n\1.*$/\1/'
}


# Added 2019-03-30 20:31
function lastarg()
{
	echo ${@: -1}
}

# Added 2019-03-30 20:31
function mkcd()
{
	local dir=$(lastarg "$1")
	mkdir -p "$dir"
	cd "$dir"
}

# Added 2019-03-30 20:31
function mkcp()
{
	local dir=$(lastarg "$@")
	mkdir -p "$dir"
	cp "$@"
}

# Added 2019-04-04 14:54
function ipfind()
{
	local user=${1:-debian} net
	net=192.168.0
	for ip in $(seq $(($last+1)) 254); do
		last=$ip
		ping -W3 -c1 $net.$ip && ssh $user@$net.$ip
		echo ret=$?
	done
}

# Added 2019-04-11 01:43
function logs()
{
	tail {.,$(git root)}/logs/{api,debug}.txt -f &
}
