VERSION=1.0.0
#lazyload=accRemoteGetAccountIdByEmail,accGetAccountIdByEmail,hotmartCSVImport

[[ -v comp ]] || typeset -ga comp

function listAudio()
{
	trap 'throw 130' INT

	sql -o row 'SELECT review_id,version,sequence,profile,review_version_id, T.status,rough_freq,mean_amp FROM review_track_stats S INNER JOIN review_version As V USING (review_id, version) INNER JOIN review_track T using (review_version_id,sequence)  WHERE T.status!="processing" AND S.status="unchecked"  ORDER BY mid_amp DESC limit 15'
	while sqlFetch row; do
	{
		checkAudio "${(@)row[1,5]}"
		loop=0
	} always {
		catch '130' && confirm $'\nExit' && { trap - INT; cancel }
	}
	done

	trap - INT
}

# Added 2020-02-10 18:12
function checkAudio()
{
	integer loop=1 bad=0
	trap 'throw 130' INT

	reviewId=$1
	version=$2
	sequence=$3
	profile=$4
	versionId=$5
	while ((loop)); do
		{
			f="rdata/reviews/$1/v$2/tracks/$3$4.mp3"
			[[ -f $f ]] || abort --ex FileIoEx_NotFound 9 $f
			mpg123 --stereo $f
			confirm 'Mark as bad quality' && bad=1
			loop=0
		} always {
			catch '130' && confirm $'\nExit' && { trap - INT; cancel }
		}
	done

	if ((bad)); then
		techo "Marking $f as bad"
		sql "UPDATE review_track SET status='processing' WHERE review_version_id=$versionId AND sequence=$sequence"
	fi
	((bad)) && _status='bad' || _status='ok'
	sql "UPDATE review_track_stats SET status='$_status' WHERE review_id=$reviewId AND version=$version AND sequence=$sequence"

	trap - INT
}

function accRemoteGetAccountIdByEmail()
{
	local val buf values
	buf=("${(@f)$(
		sql $sqlopts --ssh idiomus -t --nocolumns \
			"select account_id, type, created_at, expire_at, name," \
			"phone_country_code, phone_area_code, phone_number, password, admin" \
			"from account where email='$1'"
	)}") || abort -ex NetIoEx_Unreachable 9 idiomus 22

	(($#buf && $#buf[1])) || return 10
	rrow=(${(@s. | .)${${buf[2]#| }% |}}) #vw last one is just table bottom
	typeset -g ${2:-accountId}'='$rrow[1]

	values=()
	for val in ${rrow:0:9}; do
		values+=("$(sqlEscape $val)")
	done
	sql $sqlopts "insert into account (account_id, type, email, created_at, expire_at, name," \
		"phone_country_code, phone_area_code, phone_number, password, admin)" \
		"values ($rrow[1],$values[2],'$1',$values[3],$values[4],$values[5]," \
		"$values[6],$values[7],$values[8],$values[9],$rrow[10])"
}

function accGetAccountIdByEmail()
{
	{
		sql $sqlopts -o row "select account_id from account where email='$1'"
		(($#row1)) && typeset -g ${2:-accountId}'='$row1[1]
		#|| {
		#	accRemoteGetAccountIdByEmail $1
		#		return 1
		#}
	} always {
		if catch '*'; then
			techo here $CAUGHT
			return 1
		fi
	}
	return
	#sqlFetch row
}

function hotmartCSVImport()
{
	integer i j accountId adesao_idx cancel_idx email_idx event_exists total
	local var adesao cancelamento email out

	csvfp=${1:-_support/hotmart.csv}

	typeset -A refunded_email_index
	# like: refunded_email_index[email@something.com]=3

	include conversion
	include sql
	usedb idiomus

	#refunded_csvfp=${2:-_support/reembolsadas_app.csv}
	#chooser -v refunded_csvfp $refunded_csvfp $refunded_csvfp _support/*.csv
	#explode --stdin --csv -v refunded_csv ';' < $refunded_csvfp || return
	#refunded_email_idx=$(indexOf 'Email' '_headers')
	#for ((i=1; i<=$refunded_csv_len; i++)); do
    #    var="refunded_csv$i"
	#	refunded_email_index+=($email $i)
	#done

	missingTxt='missing'$(date "+%Y%m%d%H%M")'.txt'
	#############
	## Hotmart ##
	#############
	csvfp=${1:-_support/hotmart.csv}
	chooser -v csvfp $csvfp _support/*.csv
	techo Reading $csvfp
	explode --stdin --csv -v csv ';' < $csvfp || return
	adesao_idx=$(indexOf 'AdesÃ£o' '_headers')
	cancel_idx=$(indexOf 'Cancelamento' '_headers')
	email_idx=$(indexOf 'Email' '_headers')
	event_type='became_premium'

	for ((i=1; i<=$csv_len; i++)); do
		var="csv$i"
		premium_at=$(datetime --sql "${${(P)var}[adesao_idx]}")
		cancel_at=$(datetime --sql "${${(P)var}[cancel_idx]}")
		email=${${(P)var}[email_idx]}

		(($#email)) || {
			techo -c warn "Empty email: ${${(P)var}[@]}"
			return 1
		}

		accGetAccountIdByEmail $email 'accountId' || {
			echo $email >> $missingTxt
			techo -c warn "Account not found for email=$email index=$i"
			continue
		}
		event_exists=0
		{
			sql $sqlopts -o row \
				"SELECT account_id FROM account_event WHERE account_id=$accountId AND type='$event_type' AND created_at='$premium_at'"
			(($#row1)) && event_exists=1
		} always {
			if catch '*'; then
				techo $CAUGHT
				return 1
			fi
		}
		((event_exists)) && continue

		{
			if ((j % 20 == 0)); then
				((j)) && echo "$out;" # flush
				out="insert into account_event (account_id, type, created_at) values"
				j=0
			fi

			((j++)) && out+=','
			out+=" ($accountId, 'became_premium', '$premium_at')"
			((total++))

			#(($#cancel_at)) && {
				#((j++)) && out+=','
				#out+=" ($accountId, 'subscription_canceled', '$cancel_at')"
			#}
		} always {
			if catch '*'; then
				techo $CAUGHT
				confirm $'\nExit' && { return 1 }
			fi
		}
	done
	((j)) && echo "$out;" # flush

	echo "Total=$total"
	return
	#################
	## GetResponse ##
	#################

	getresp_csvfp='_support/getResponse.csv'
	explode --stdin --csv -v grcsv ',' < $getresp_csvfp || return
	adesao_idx=$(indexOf 'sign_up' '_headers')
	email_idx=$(indexOf 'email' '_headers')

	j=0
	for ((i=1; i<=$grcsv_len; i++)); do
        var="grcsv$i"
		freemium_at=$(datetime --sql ${(Q)${(P)var}[adesao_idx]}) # (Q) removes quoting
		email=${${(P)var}[email_idx]}

		(($#email)) || {
			techo -c warn "Empty email: ${${(P)var}[@]}"
			return 1
		}

        accGetAccountIdByEmail $email 'accountId' || {
			echo $email >> missing.txt
			techo -c warn "Account not found for email=$email index=$i (GetResponse)"
			continue
		}
		event_exists=0
		{
			sql $sqlopts -o row \
				"SELECT account_id FROM account_event WHERE account_id=$accountId AND type='became_freemium'"
			(($#row1)) && event_exists=1
		} always {
			if catch '*'; then
				techo $CAUGHT
				return 1
			fi
		}
		((event_exists)) && continue

		{
			if ((j % 20 == 0)); then
				((j)) && echo "$out;" # flush
				out="insert into account_event (account_id, type, created_at) values"
				j=0
			fi

			((j++)) && out+=','
			out+=" ($accountId, 'became_freemium', '$freemium_at')"
		} always {
			if catch '*'; then
				techo $CAUGHT
				confirm $'\nExit' && { return 1 }
			fi
		}
	done
	((j)) && echo "$out;" # flush

}
